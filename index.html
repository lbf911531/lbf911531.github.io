<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.5.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="博客">
<meta property="og:type" content="website">
<meta property="og:title" content="埋书小楼">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="埋书小楼">
<meta property="og:description" content="博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="书生">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>埋书小楼</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">埋书小楼</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">清光未泯，来岁无穷</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="书生"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">书生</p>
  <div class="site-description" itemprop="description">博客</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/lbf911531" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lbf911531" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/1459029798@qq.com" title="E-Mail → 1459029798@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



          </div>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/yourname" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/01/promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="书生">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="埋书小楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/01/promise/" class="post-title-link" itemprop="url">promise初探</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-07-01 18:38:51 / 修改时间：19:15:38" itemprop="dateCreated datePublished" datetime="2021-07-01T18:38:51+08:00">2021-07-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><i class="fa fa-tags"></i>定义</h2><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理且更强大。它最早由社区提出并实现，ES6将其写进了语言标准，统一了用法，并原生提供了Promise对象。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a><i class="fa fa-tags"></i>特点</h2><ol>
<li>对象的状态不受外界影响 （3种状态）</li>
</ol>
<ul>
<li>pending</li>
<li>resolved</li>
<li>rejected</li>
</ul>
<ol start="2">
<li>一旦状态改变就不会再变 （两种状态改变：成功或失败）</li>
</ol>
<ul>
<li>Pending -&gt; Fulfilled</li>
<li>Pending -&gt; Rejected</li>
</ul>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a><i class="fa fa-tags"></i>API</h2><table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Promise.prototype.then</td>
<td>链式操作</td>
</tr>
<tr>
<td>Promise.prototype.catch</td>
<td>捕捉错误</td>
</tr>
<tr>
<td>Promise.all</td>
<td>入参是数组，成员为promise实例，仅当所有成员都是resolved，改方法的实例才是resolved</td>
</tr>
<tr>
<td>Promise.race</td>
<td>与all相对，可以理解为some</td>
</tr>
<tr>
<td>Promise.resolve</td>
<td>返回状态为resolved的实例</td>
</tr>
<tr>
<td>Promise.reject</td>
<td>返回状态为rejected的实例</td>
</tr>
</tbody></table>
<h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a><i class="fa fa-tags"></i>模拟</h2><h3 id="公共方法"><a href="#公共方法" class="headerlink" title="公共方法"></a>公共方法</h3><pre><code class="javascript">function isFunction(fn) &#123;
  return Object.prototype.toString.call(fn) === &quot;[object Function]&quot;;
&#125;;
// 判断对象是否可迭代即遍历
function isIterable(obj) &#123;
  return obj &amp;&amp; Object.prototype.toString.call(obj[Symbol.iterator]) === &quot;[object Function]&quot;;
&#125;;
</code></pre>
<h3 id="构造Promise"><a href="#构造Promise" class="headerlink" title="构造Promise"></a>构造Promise</h3><pre><code class="javascript">const PENDING = &quot;pending&quot;;
const RESOLVED = &quot;resolved&quot;;
const REJECTED = &quot;rejected&quot;;

class MyPromise &#123;

  constructor(executor) &#123;
    if (!isFunction(executor)) &#123;
      throw new Error(&quot;promise need a function as a paramter&quot;);
    &#125;

    this._value;
    this._status = PENDING;
    this._callbacks = [];
    /**
     * promise 特性： 
     * 1.状态改变只能由 pending到 resolved 或者 rejected
     * 2.创建之初状态为 pending
     * 3.状态一旦由pending变动了以后，就不能再修改了 
     * 4.promise的回调是异步执行的
     */
    this._onResolved = function onResolve(value) &#123;
      if (this._status !== PENDING) return;
      this._status = RESOLVED;
      this._value = value;
      let fn;
      while (fn = this._callbacks.shift()) &#123;
        const run = fn.onResolved;
        setTimeout(() =&gt; &#123;
          run(value);
        &#125;, 0);
      &#125;
    &#125;

    this._onRejected = function onRejected(reason) &#123;
      if (this._status === !PENDING) return;
      this._status = REJECTED;
      this._value = reason;
      let fn;
      while (fn = this._callbacks.shift()) &#123;
        const run = fn.onRejected;
        setTimeout(() =&gt; &#123;
          run(reason);
        &#125;, 0);
      &#125;
    &#125;

    try &#123;
      // bind 避免 this._onResolved 调用者成为 windows, 将 Promise 绑定上去 
      executor(this._onResolved.bind(this), this._onRejected.bind(this));
    &#125; catch (reason) &#123;
      this._onRejected.bind(this, reason);
    &#125;
  &#125;
&#125;
</code></pre>
<h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then"></a>Promise.prototype.then</h3><pre><code class="javascript">MyPromise.prototype.then = function (onResolved, onRejected) &#123;
  /**
   * promise 特性：
   * 5. then 会返回一个新的promise对象，以此形成一个 promise chain，
   * 6. 当前 promise.then 的执行结果 会作为 下一环 promise 的参数，
   * 同时也是决定了下一环的状态
   * 7. throw error 后也将进入 rejected
   * 8. promise 存在 穿透的特性,如 .then().then((onResolve,onReject) =&gt; &#123;&#125;)
   * 其实可以变成 .then((value =&gt; value, reason=&gt; throw reason)=&gt; &#123;&#125;).then(...)
   */
  return new MyPromise((onResolvedNext, onRejectedNext) =&gt; &#123;

    onResolved = onResolved || (value =&gt; value);
    onRejected = onRejected || (reason =&gt; &#123; throw reason &#125;); // 这里可以改成Promise.reject()更好

    const _handle = (callback) =&gt; &#123;
      try &#123;
        const result = callback(this._value);
        if (result instanceof MyPromise) &#123;
          result.then(onResolvedNext, onRejectedNext);
        &#125; else &#123;
          onResolvedNext(result);
        &#125;
      &#125; catch (reason) &#123;
        onRejectedNext(reason);
      &#125;
    &#125;

    switch (this._status) &#123;
      case PENDING:
        // 用 callbacks保留，是为了处理 先定义了 回调，后确认了promise状态的情况
        /**
         * eg:
         * new Promise(
         *  (resolve,reject) =&gt; &#123;
         *   setTimeout(() =&gt; &#123;resolve(1)&#125;
         *  ),1000&#125;
         * )
         * .then(value =&gt; &#123;&#125;,reason =&gt; &#123;&#125;)
         */
        this._callbacks.push(&#123;
          onResolved: () =&gt; &#123; _handle(onResolved) &#125;,
          onRejected: () =&gt; &#123; _handle(onRejected) &#125;
        &#125;);
        break;
      case RESOLVED:
        setTimeout(() =&gt; &#123;
          _handle(onResolved);
        &#125;, 0);
        break;
      case REJECTED:
        setTimeout(() =&gt; &#123;
          _handle(onRejected);
        &#125;, 0);
        break;
      default: break;
    &#125;
  &#125;);
&#125;
</code></pre>
<h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch"></a>Promise.prototype.catch</h3><pre><code class="javascript">MyPromise.prototype.catch = function (onRejected) &#123;
  return this.then(undefined, onRejected);
&#125;
</code></pre>
<h3 id="promise-resolve"><a href="#promise-resolve" class="headerlink" title="promise.resolve"></a>promise.resolve</h3><pre><code class="javascript">/**
 * 要根据 value的类型判断
 * 返回结果是一个 promise对象
 */
MyPromise.resolve = function (value) &#123;
  if (value instanceof MyPromise) &#123;
    return value;
  &#125; else &#123;
    return new MyPromise((resolve) =&gt; &#123;
      resolve(value);
    &#125;);
  &#125;
&#125;
</code></pre>
<h3 id="promise-reject"><a href="#promise-reject" class="headerlink" title="promise.reject"></a>promise.reject</h3><pre><code class="javascript">// reject 无论传入什么，当前状态都是 rejected
MyPromise.reject = function (reason) &#123;
  return new MyPromise((resolve, reject) =&gt; &#123;
    reject(reason);
  &#125;);
&#125;
</code></pre>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><pre><code class="javascript">/**
 * 入参是可迭代类型
 * 数组中可以是promise对象，也可以是数字等
 * 只有当所有的都resolved的，all返回的promise对象的状态才为resolved
 * 否则只要有一个是rejected则 all返回的promise对象状态为rejected 
 * 且是第一个抛出的错误信息
 */
MyPromise.all = function (promises) &#123;
  return new MyPromise((onResolved, onRejected) =&gt; &#123;
    if (!isIterable(promises)) onRejected(promises);
    if (promises.length === 0) onResolved(promises);
    const values = [];
    let count = 0;
    for (var i = 0, len = promises.length; i &lt; len; i += 1) &#123;
      this.resolve(promises[i]).then(
        value =&gt; &#123;
          values[count] = value;
          count += 1;
          if (count === promises.length) onResolved(values);
        &#125;,
        reason =&gt; &#123;
          onRejected(reason);
        &#125;
      );
    &#125;
  &#125;);
&#125;
</code></pre>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><pre><code class="javascript">/**
 * 入参是可迭代类型
 * 数组中可以是promise对象，也可以是数字等
 * 只要有一个resolve的，即race所返回的promise对象为 resolved
 * 以下MDN官网描述：
 * race 函数返回一个 Promise，它将与第一个传递的 promise 相同的完成方式被完成。
 * 它可以是完成（ resolves），
 * 也可以是失败（rejects），这要取决于第一个完成的方式是两个中的哪个
 * 如果传的迭代是空的，则返回的 promise 将永远等待
 */
MyPromise.race = function (promises) &#123;
  return new MyPromise((onResolved, onRejected) =&gt; &#123;
    if (!isIterable(promises)) onRejected(promises);
    for (var i = 0, len = promises.length; i &lt; len; i += 1) &#123;
      MyPromise.resolve(promises[i]).then(
        value =&gt; &#123;
          console.log(value)
          onResolved(value);
        &#125;,
        reason =&gt; &#123;
          onRejected(reason);
        &#125;
      );
    &#125;
  &#125;);
&#125;
</code></pre>
<h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h3><pre><code class="javascript">// any 与 all 正好相反
MyPromise.any = function (promises) &#123;
  return new MyPromise((onResolved, onRejected) =&gt; &#123;
    if (!isIterable(promises)) onRejected(promises);
    if (promises.length === 0) onResolved(promises);
    const values = [];
    let count = 0;
    for (var i = 0, len = promises.length; i &lt; len; i += 1) &#123;
      this.resolve(promises[i]).then(
        value =&gt; &#123;
          onResolved(value);
        &#125;,
        reason =&gt; &#123;
          values[count] = reason;
          count += 1;
          if (count === promises.length) onRejected(values);
        &#125;
      );
    &#125;
  &#125;);
&#125;

MyPromise.finally = function (fn) &#123;
  return this.then(
    value =&gt; &#123; this.resolve(fn()).then(() =&gt; value) &#125;,
    reason =&gt; &#123; this.resolve(fn()).then(() =&gt; &#123; throw reason &#125;) &#125;
  )
&#125;
</code></pre>
<h2 id="思路总结"><a href="#思路总结" class="headerlink" title="思路总结"></a><i class="fa fa-tags"></i>思路总结</h2><ol>
<li>创建一个 promise class</li>
<li>class内部构造器接受一个function 参数，通过它访问class内部的 onResolved, onRejected</li>
<li>class内部需要定义三个变量， status存放状态，value存放当前入参， callbacks数组存放因异步修改状态之后执行的 resolved，rejected</li>
<li>定义 this.onResolved, this.onRejected两个内部方法</li>
<li>上诉两个内部方法中，需要根据状态判断是否要执行（特性：pending状态一旦更改则不会再变）遍历 classBacks数组，取出内部压入的方法，传入value,赋值this.value = value,并借助定时器执行</li>
<li>对第二步中的function 使用 try …catch 包裹捕获未知异常，执行 function(this.onResolved.bind(this),this.onRejected.bind(this))</li>
<li>原型链上定义then方法，方法需要根据当前状态switch…case判断</li>
</ol>
<ul>
<li>7.1. 如果是pending，则将传入的resolved,rejected压入callbacks,</li>
<li>7.2. 如果是resolved,则执行resolved方法</li>
<li>7.3. 如果是rejected，则执行rejected方法</li>
<li>7.4. then方法的核心，需要返回一个新的promise对象</li>
<li>7.5. <ul>
<li>因要返回新的promise对象，必然就有 new Promise((onResolvedNext,onRejectedNext) =&gt; {…})的 onResolvedNext，onRejectedNext两个方法，</li>
<li>而为了符合【特性：上一级的resolve，rejected执行返回的结果是下一级的入参】</li>
<li>因此还需要 将then里面的onResolvedCur,onRejectedCur的返回结果判断一下返回值类型是promise还是普通的，</li>
<li>promise就用then方法传入，普通的就用普通入参方式传递，result.then(onResolvedNext, onRejectedNext) 或 onResolvedNext(result)/onRejectedNext(result)</li>
<li>{7.5 这里是配合 7.2，7.3，因为7.2,7.3才会直接执行resolved，rejected}</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/29/editor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="书生">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="埋书小楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/29/editor/" class="post-title-link" itemprop="url">模拟TextArea-踩坑记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-29 20:02:15" itemprop="dateCreated datePublished" datetime="2021-06-29T20:02:15+08:00">2021-06-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-30 17:55:18" itemprop="dateModified" datetime="2021-06-30T17:55:18+08:00">2021-06-30</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="思路提供"><a href="#思路提供" class="headerlink" title="思路提供"></a><i class="fa fa-tags"></i>思路提供</h2><ol>
<li><p>原生 div + textarea ，通过调整系列样式，将div设置为透明色，以textarea所在外层div包裹,相对外层div绝对定位。</p>
</li>
<li><p>使用div+contentEditable属性，将div设置为可编辑状态</p>
<p>ps: 在使用contentEditable属性时，可以放心大胆使用。IE在这里是最先支持的，</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th>Google</th>
<th>IE</th>
<th>Firefox</th>
<th>Safari</th>
<th>Opera</th>
</tr>
</thead>
<tbody><tr>
<td align="left">contentEditable</td>
<td>11.0</td>
<td>5.5</td>
<td>3.0</td>
<td>3.2</td>
<td>10.6</td>
</tr>
</tbody></table>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a><i class="fa fa-tags"></i>实践</h2><h3 id="实践-‘思路一’"><a href="#实践-‘思路一’" class="headerlink" title="实践-‘思路一’"></a>实践-‘思路一’</h3><p>既然是踩坑，就先从第一条思路开始尝试</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/29/editor/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/28/hexo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="书生">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="埋书小楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/28/hexo/" class="post-title-link" itemprop="url">hexo</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-28 19:43:20" itemprop="dateCreated datePublished" datetime="2021-06-28T19:43:20+08:00">2021-06-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-29 22:13:18" itemprop="dateModified" datetime="2021-06-29T22:13:18+08:00">2021-06-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="从零开始搭建hexo-blog"><a href="#从零开始搭建hexo-blog" class="headerlink" title="从零开始搭建hexo blog"></a>从零开始搭建hexo blog</h1><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a><i class="fa fa-tags"></i>准备环境</h2><ol>
<li>安装node</li>
<li>安装Git</li>
<li>安装hexo 脚手架 <pre><code class="bash">$ npm install hexo-cli -g
$ hexo -v
</code></pre>
</li>
</ol>
<p><img src="../images/other/hexo/1.png" alt="version"></p>
<ol start="4">
<li>创建一个空白文件夹，如/blog<pre><code class="bash">$ cd /blog
$ hexo init
$ npm i
</code></pre>
</li>
<li>启动服务器<pre><code class="bash">$ hexo s
</code></pre>
</li>
<li>访问 <a target="_blank" rel="noopener" href="http://localhost:4000/">http://localhost:4000/</a></li>
</ol>
<p>至此一个简单的blog完成搭建</p>
<h2 id="美化博客"><a href="#美化博客" class="headerlink" title="美化博客"></a><i class="fa fa-tags"></i>美化博客</h2><ol>
<li><p>修改基本信息<br>进入 ./_config.yml 文件，配置 #side 中的title,subtitle,description…<br><img src="../images/other/hexo/side-config.png" alt="side基本配置"><br>更多配置参考 <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/configuration">https://hexo.io/zh-cn/docs/configuration</a></p>
</li>
<li><p>引入博客主题</p>
<p>  2.1. 挑选主题 （<a target="_blank" rel="noopener" href="https://hexo.io/themes/%EF%BC%89">https://hexo.io/themes/）</a></p>
<p>  2.2. 安装主题插件,成功后会在 /blog/themes 下生成next目录（个人采用了hexo-theme-next）</p>
<p>  2.3. 之后访问_config.yml文件，修改theme: next，（theme的值需要和clone创建的文件夹名一致）</p>
<pre><code class="bash">$ git clone https://github.com/next-theme/hexo-theme-next themes/next
</code></pre>
</li>
</ol>
<ol start="3">
<li><p>引入canvas-next 粒子动态背景</p>
<p>3.1.  <code>/blog/source/_data/footer.njk</code>，如果没有，则按照该pah创建</p>
<p>3.2. 复制下图中script标签全内容到 <code>footer.njk</code><br><img src="../images/other/hexo/canvas-next.png" alt="canvas-next"></p>
<p>3.3. 修改<code>/blog/theme/next/_config.yml</code>文件中的<code>custom_file_path:</code>，解开 footer的注释</p>
<pre><code class="yaml"># Define custom file paths.
# Create your custom files in site directory `source/_data` and uncomment needed files below.
custom_file_path:
  # ...
  footer: source/_data/footer.njk
  # ...
</code></pre>
<p>详情参考 <a target="_blank" rel="noopener" href="https://github.com/theme-next/theme-next-canvas-nest">https://github.com/theme-next/theme-next-canvas-nest</a></p>
<p>3.4. 修改<code>/blog/theme/next/_config.yml</code>文件中的<code>canvas_ribbon</code>，设置<code>enabled：true</code>，渲染背景彩带效果（该效果为next自带，默认不开启）</p>
</li>
</ol>
<h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a><i class="fa fa-tags"></i>创建文件</h2><ol>
<li><p>创建标签</p>
<pre><code class="bash">$ hexo new page tags
</code></pre>
<p>之后，会在 <code>/blog/source</code>下自动创建<code>tags/index.md</code>，配置index.md如下</p>
<pre><code class="markdown">title: tags
date: 2017-12-02 21:01:24
type: &quot;tags&quot;
</code></pre>
</li>
<li><p>创建分类</p>
<pre><code class="bash">$ hexo new page categories
</code></pre>
<p>与创建标签一致，但配置<code>type = categories</code></p>
</li>
<li><p>创建md文件</p>
<pre><code class="bas">$ hexo new [file]
</code></pre>
<p>之后，会在<code>/blog/souce/_post</code>下生成<code>[file].md</code>，配置：</p>
<pre><code class="markdown">---
title: [file]
date: 2021-06-28 19:43:20
tags: other // 自定义
categories: 前端 // 自定义
---
...
</code></pre>
</li>
<li><p>编译md为html</p>
<pre><code class="bash">$ hexo g
</code></pre>
</li>
<li><p> 本地预览效果 </p>
</li>
</ol>
<pre><code class="bash">$ hexo s
</code></pre>
<h2 id="发布到GitHub"><a href="#发布到GitHub" class="headerlink" title="发布到GitHub"></a><i class="fa fa-tags"></i>发布到GitHub</h2><ol>
<li>发布之前，需要登录个人GitHub，并创建一个名为“ [用户名].github.io” 的仓库；注意：可以采用自己的用户名，但<code>.github.io</code>仓库一个账号只能拥有一个。</li>
<li>修改本地 /_config.yml 文件（以用户名为 test为例, repository 在仓库创建成功后可直接复制）<pre><code class="markdown">deploy:
type: git
repository: git@github.com:test/test.github.io.git
branch: master
</code></pre>
</li>
<li>如果个人Git账号没有配置SSH，请先配置SSH<pre><code class="bash">$ cd ~/.ssh
$ ls  // id_rsa.pub 如果存在则跳过 ssh-keygen -t rsa -C
$ ssh-keygen -t rsa -C your.email  // 如果没有该文件
$ cat id_rsa.pub // 然后拷贝文件内容，到Git上新建SSH
$ ssh -T git@github.com // 验证
</code></pre>
</li>
<li>本地安装hexo-deployer-git<pre><code class="bash">$ npm install hexo-deployer-git --save
</code></pre>
</li>
<li>本地执行 hexo d 即可</li>
<li>线上访问 test.github.io 即可浏览个人搭建的博客</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/27/front-listen/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="书生">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="埋书小楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/27/front-listen/" class="post-title-link" itemprop="url">前端性能监控初探</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-27 21:29:05" itemprop="dateCreated datePublished" datetime="2021-06-27T21:29:05+08:00">2021-06-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-01 18:36:39" itemprop="dateModified" datetime="2021-07-01T18:36:39+08:00">2021-07-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-采集相关信息"><a href="#1-采集相关信息" class="headerlink" title="1. 采集相关信息"></a>1. 采集相关信息</h2><ul>
<li><p>环境信息： </p>
<ul>
<li>url:  window.location.href （当前页面）</li>
<li>ua: window.navigator.userAgent （ userAgent信息，包含操作系统和浏览器的类型、版本等 ）</li>
<li>token信息</li>
</ul>
</li>
<li><p>性能信息</p>
<ul>
<li>​    window.performance </li>
</ul>
<p><img src="../images/front-listen/timing.png" alt="1607391878316"></p>
</li>
</ul>
<p>window.performance 下的timing属性记录了重定向，DNS解析，TCP连接，SSL连接，资源加载，数据传输，TTFB网络请求耗时的相关起止时间戳。</p>
<p>公式：</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>计算</th>
</tr>
</thead>
<tbody><tr>
<td>重定向耗时</td>
<td>redirectEnd - redirectStartDNS</td>
</tr>
<tr>
<td>解析耗时</td>
<td>domainLookupEnd - domainLookupStartTCP</td>
</tr>
<tr>
<td>连接耗时</td>
<td>connectEnd - connectStartSSL</td>
</tr>
<tr>
<td>连接耗时</td>
<td>connectEnd - secureConnectionStartTTFB</td>
</tr>
<tr>
<td>网络请求耗时</td>
<td>responseStart - requestStart</td>
</tr>
<tr>
<td>数据传输耗时</td>
<td>responseEnd - responseStart</td>
</tr>
<tr>
<td>资源加载耗时</td>
<td>loadEventStart - domContentLoadedEventEnd</td>
</tr>
</tbody></table>
<ul>
<li><p>语法错误</p>
<pre><code class="javascript">function listenerError() &#123;
    window.addEventListener(&#39;error&#39;, (event) =&gt; &#123;
        if (event.target.localName) &#123;
            console.log(&#39;这是资源错误&#39;, event);
        &#125;
        else &#123;
            console.log(&#39;这是代码错误&#39;, event);
        &#125;
    &#125;, true)
&#125;
// window.addEventListener(&#39;error&#39;) 比window.onError先执行，它可以全局捕获资源加载错误，但不能通过返回true的方式阻止执行默认事件处理函数

 function listenerPromiseError() &#123;
    window.addEventListener(&#39;unhandledrejection&#39;, (event) =&gt; &#123;
        console.log(&#39;这是Promise场景中错误&#39;, event);
    &#125;)
&#125;
// Promise场景的处理方式有所不同，当Promise被reject且没有reject处理器的时候，会触发unhandlerejection事件，所以通过监听unhandlerejection的事件来捕获错误。
</code></pre>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/27/proxy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="书生">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="埋书小楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/27/proxy/" class="post-title-link" itemprop="url">proxy</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-27 21:27:42" itemprop="dateCreated datePublished" datetime="2021-06-27T21:27:42+08:00">2021-06-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-29 22:13:56" itemprop="dateModified" datetime="2021-06-29T22:13:56+08:00">2021-06-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Proxy-和-Object-defineProperty"><a href="#Proxy-和-Object-defineProperty" class="headerlink" title="Proxy 和 Object.defineProperty"></a>Proxy 和 Object.defineProperty</h1><h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a><i class="fa fa-tags"></i>导言</h2><p>Proxy来自于es6</p>
<p>Object.defineProperty 来自于es5</p>
<p>二者本质都是通过 对象的 set , get 方法实现中间拦截处理。vue的双向数据绑定可以说是基于这个特性实现的。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a><i class="fa fa-tags"></i>使用</h2><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><pre><code class="javascript">/**
*  target: 要兼容的对象，可以是一个对象，数组,函数等等
*  handler: 是一个对象，里面包含了可以监听这个对象的行为函数，
*/
const proxy = new Proxy(target, handler)
</code></pre>
<p>handler 里面的方法列表:</p>
<p><code>handler</code>里面的方法可以有以下这十三个，每一个都对应的一种或多种针对<code>proxy</code>代理对象的操作行为</p>
<ol>
<li><p><code>handler.get</code></p>
<p>当通过<code>proxy</code>去读取对象里面的属性的时候，会进入到<code>get</code>钩子函数里面</p>
</li>
<li><p><code>handler.set</code></p>
<p>当通过<code>proxy</code>去为对象设置修改属性的时候，会进入到<code>set</code>钩子函数里面</p>
</li>
<li><p><code>handler.has</code></p>
<p>当使用<code>in</code>判断属性是否在<code>proxy</code>代理对象里面时，会触发<code>has</code>，比如</p>
<pre><code class="javascript">const obj = &#123;
  name: &#39;zhangsan&#39;
&#125;
console.log(&#39;name&#39; in obj)
</code></pre>
</li>
<li><p><code>handler.deleteProperty</code></p>
<p>当使用<code>delete</code>去删除对象里面的属性的时候，会进入deleteProperty`钩子函数</p>
</li>
<li><p><code>handler.apply</code></p>
<p>当<code>proxy</code>监听的是一个函数的时候，当调用这个函数时，会进入<code>apply</code>钩子函数</p>
</li>
<li><p><code>handle.ownKeys</code></p>
<p>当通过<code>Object.getOwnPropertyNames</code>,<code>Object.getownPropertySymbols</code>,<code>Object.keys</code>,<code>Reflect.ownKeys</code>去获取对象的信息的时候，就会进入<code>ownKeys</code>这个钩子函数</p>
</li>
<li><p><code>handler.construct</code></p>
<p>当使用<code>new</code>操作符的时候，会进入<code>construct</code>这个钩子函数</p>
</li>
<li><p><code>handler.defineProperty</code></p>
<p>当使用<code>Object.defineProperty</code>去修改属性修饰符的时候，会进入这个钩子函数</p>
</li>
<li><p><code>handler.getPrototypeOf</code></p>
<p>当读取对象的原型的时候，会进入这个钩子函数</p>
</li>
<li><p><code>handler.setPrototypeOf</code></p>
<p>当设置对象的原型的时候，会进入这个钩子函数</p>
</li>
<li><p><code>handler.isExtensible</code></p>
<p>当通过<code>Object.isExtensible</code>去判断对象是否可以添加新的属性的时候，进入这个钩子函数</p>
</li>
<li><p><code>handler.preventExtensions</code></p>
<p>当通过<code>Object.preventExtensions</code>去设置对象不可以修改新属性时候，进入这个钩子函数</p>
</li>
<li><p><code>handler.getOwnPropertyDescriptor</code></p>
<p>在获取代理对象某个属性的属性描述时触发该操作，比如在执行 <code>Object.getOwnPropertyDescriptor(proxy, &quot;foo&quot;)</code> 时会进入这个钩子函数</p>
</li>
</ol>
<pre><code class="javascript">var obj = &#123;
    name: &#39;zhangsan&#39;
&#125;
const proxy = new Proxy(obj,&#123;
    get(target,key) &#123;
        if (key === &#39;name&#39;) return &#39;hellow&#39;
        else return target[key];
    &#125;,
    set(target,key,value) &#123;
        if (key === &#39;age&#39;) &#123;
            target[key] = 18;
            return true;
        &#125; else &#123;
            target[key] = value;
            return true
        &#125;
    &#125;
&#125;)
proxy.age = 19;
console.log(obj) //&#123;name: &#39;zhangsan&#39;,age: 18&#125;
console.log(proxy.name) // &#39;hellow&#39;;
console.log(obj.name) // &#39;zhangsan&#39;
console.log(proxy.age,obj.age) // 18
</code></pre>
<h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><p>上述如果用<code>Object.defineProperty </code>去重写的话：</p>
<pre><code class="javascript">function observe(obj, callback) &#123;
  Object.keys(obj).forEach(key =&gt; &#123;
    Object.defineProperty(obj, key, &#123;
      configurable: true,
      enumerable: true,
      get() &#123;
        if (key === &#39;name&#39;) &#123;
            return &#39;hellow&#39;
        &#125; else return obj[key]
      &#125;,
      // 当属性的值被修改时，会调用set，这时候就可以在set里面调用回调函数
      set(newVal) &#123;
        if (key === &#39;age&#39;) &#123;
            obj[key] = 18;
        &#125; else obj[key] = newVal
        if(callback) callback(key, newVal)
      &#125;
    &#125;)
  &#125;)
  return obj
&#125;
var obj = &#123;
    name: &#39;zhangsan&#39;
&#125;
const proxy = observe(obj);
proxy.age = 19;
console.log(obj)
console.log(proxy.name)
console.log(obj.name) 
console.log(proxy.age,obj.age) 
</code></pre>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>使用<code>Object.defineProperty</code>无法监听到新增属性，但是使用<code>Proxy</code>是可以监听到的。对比上面两段代码可以发现有以下几点不同</p>
<ul>
<li><code>Object.defineProperty</code>监听的是对象的每一个属性，而<code>Proxy</code>监听的是对象自身</li>
<li>使用<code>Object.defineProperty</code>需要遍历对象的每一个属性，对于性能会有一定的影响</li>
<li><code>Proxy</code>对新增的属性也能监听到，但<code>Object.defineProperty</code>无法监听到。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/27/iterator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="书生">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="埋书小楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/27/iterator/" class="post-title-link" itemprop="url">iterator and Generator</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-27 21:26:15" itemprop="dateCreated datePublished" datetime="2021-06-27T21:26:15+08:00">2021-06-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-29 22:13:35" itemprop="dateModified" datetime="2021-06-29T22:13:35+08:00">2021-06-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Iterator和Generator"><a href="#Iterator和Generator" class="headerlink" title="Iterator和Generator"></a>Iterator和Generator</h1><h2 id="Iterator遍历器对象"><a href="#Iterator遍历器对象" class="headerlink" title="Iterator遍历器对象"></a><i class="fa fa-tags"></i>Iterator遍历器对象</h2><p>ES6 规定，默认的 Iterator 接口部署在数据结构的 <strong>Symbol.iterator</strong> 属性，或者说，一个数据结构只要具有<strong>Symbol.iterator</strong>属性，就可以认为是“可遍历的”（iterable）。<strong>Symbol.iterator</strong> 属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。调用这个函数时，每次都会返回一个迭代器。</p>
<ul>
<li>探究数组，类数组，字符串是否存在iterator</li>
</ul>
<pre><code class="javascript">//数组：
var arr = [1,2,3];
var arrIterF = arr[Symbol.iterator]
   //arrIterF ==&gt; &quot;function&quot;
var arrIter = arrIterF();
  //arrIter  ==&gt; &quot;Array Iterator&quot;对象
arrIter.next() 
  //==&gt;  value: 1, done: false;
arrIter.next() 
  //==&gt;  value: 2 done: false;
arrIter.next() 
  //==&gt;  value: 3, done: false;
arrIter.next() 
  //==&gt;  value: undefined, done: true;
//字符串
var str = &quot;hi&quot;;
var strInter = str[Symbol.iterator]();
   //strInter ==&gt; StringIterator &#123;&#125;
//类数组对象
var o =　&#123;0:42,1:52,2:63,length:3,push: function (value) &#123;var len = o.length; o[len] = value; o.length +=1&#125;&#125;
console.log(o[Symbol.iterator]) // undefined
 类数组对象不存在iterator接口，需要自行定义
</code></pre>
<ul>
<li><p>遍历器对象的next（），return（），throw（）</p>
<ol>
<li><p>iterator必然需要 <code>next（）</code>,<code>return(),throw()</code>可选</p>
</li>
<li><p>假设在<code>for...of</code>循环中需要提前退出（出错或者，break），就会调用return方法</p>
<pre><code class="javascript">function readLinesSync(file) &#123;
  return &#123;
    [Symbol.iterator]() &#123;
      return &#123;
        next() &#123;
          return &#123; done: false &#125;;
        &#125;,
        return() &#123;
          file.close();
          return &#123; done: true &#125;;
        &#125;
      &#125;;
    &#125;,
  &#125;;
&#125;

// 情况一
for (let line of readLinesSync(fileName)) &#123;
  console.log(line);
  break;  //--&gt; 调用return（）；
&#125;

// 情况二
for (let line of readLinesSync(fileName)) &#123;
  console.log(line);
  throw new Error(); // --&gt;调用return（）；
&#125;
</code></pre>
</li>
</ol>
</li>
<li><p>for…of 实质上是依赖于iterator接口的一种循环方式</p>
<p><code>for...of</code>循环自动调用它的Symbol.iterator函数来构建一个迭代器。</p>
<p>如：<code>for...of</code>循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如<code>arguments</code>对象、DOM NodeList 对象）、Generator 对象，以及字符串。 </p>
</li>
<li><p>for…in 读取键名，for…of读取键值，（借助数组实例的entries（），keys（））方法可以获取键名，键值对</p>
</li>
</ul>
<h2 id="Generator-生成器"><a href="#Generator-生成器" class="headerlink" title="Generator 生成器"></a><i class="fa fa-tags"></i>Generator 生成器</h2><p>​        生成器本身并不是 iterable  ，它可以说是一个自带迭代器的函数。虽然类似iterable，其原因是当你执行生成器，就得到了一个迭代器。</p>
<pre><code class="javascript">function *something() &#123;     
    var nextVal;       
    while (true) &#123;          
        if (nextVal === undefined) &#123; nextVal = 1;&#125;          
        else &#123;            
            nextVal = (3 * nextVal) + 6;   
        &#125;           
        yield nextVal;     
    &#125;  
&#125; 

for (var i of something()) &#123; if (i&gt; 500) &#123;console.log(i)&#125; &#125;

</code></pre>
<p>题外笔记：<code>while...true</code>如果没有给定<code>return</code>或者<code>break</code>，那么很容易同步地无限循环，并阻塞和锁住浏览器 UI  。如果搭上 生成器的<code>yield</code>,yield会在每次迭代后都会暂停。函数*something()的状态（作用域）会被保持 ，        即意味着不需要闭包在调用之间保持变量状态  。 </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/27/react-diff/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="书生">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="埋书小楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/27/react-diff/" class="post-title-link" itemprop="url">fiber and diff初探</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-27 20:36:32" itemprop="dateCreated datePublished" datetime="2021-06-27T20:36:32+08:00">2021-06-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-29 22:14:11" itemprop="dateModified" datetime="2021-06-29T22:14:11+08:00">2021-06-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="react-fiber简介及15，16两版本Diff"><a href="#react-fiber简介及15，16两版本Diff" class="headerlink" title="react-fiber简介及15，16两版本Diff"></a>react-fiber简介及15，16两版本Diff</h1><h2 id="fiber"><a href="#fiber" class="headerlink" title="fiber"></a><i class="fa fa-tags"></i>fiber</h2><p>React 16版本之前 Diff 算法的实现是基于深度优先遍历虚拟DOM树结构，在这个过程中由于每次 Diff 都从根节点开始遍历。这会由于不可控因素，导致在底层执行任务的时候线程阻塞导致页面卡顿。[具体卡顿原因可以从浏览器渲染帧引申出去，简言之就是大执行量的同步任务阻塞线程，导致浏览器不能及时拿回线程控制权]</p>
<p>因此React 16对底层做了一次重构：</p>
<ol>
<li>首先是基于虚拟DOM树，采用链表形式构建了一颗fiber树</li>
</ol>
<p>  <img src="../images/diff/1616311309865.png" alt="1616311309865"></p>
<pre><code class="javascript">// 如上图，其关系可以转化成下方代码，root拥有两个子节点，第一个子节点也拥有两个子节点
var root = &#123; type: &quot;div&quot;, key: &quot;root&quot; &#125;;
var firstChild = &#123; type: &quot;div&quot;, key: &quot;firstChild&quot;, return: root &#125;;
var secondChild = &#123; type: &quot;div&quot;, key: &quot;secondChild&quot;,return: root &#125;;
var firstSunNode = &#123; type: &quot;div&quot;, key: &quot;firstSunNode&quot;, return: firstChild &#125;;
var secondSunNode = &#123; type: &quot;div&quot;, key: &quot;secondSunNode&quot;, return: firstChild &#125;;
  
 root.child = firstChild;
 firstChild.sibling = secondChild;
 firstChild.child = firstSunNode;

 firstSunNode.sibling = secondSunNode;
</code></pre>
<p>   fiber节点都拥有 <code>child</code>,<code>return</code>,<code>sibling</code>,三个指针</p>
<p>  1.1 child: 用来指向当前节点的第一个子节点</p>
<p>  1.2 return: 用来指向当前节点的父节点</p>
<p>  1.3 sibling: 用来指向当前节点的兄弟节点</p>
<p><img src="../images/diff/1616311816104.png" alt="1616311816104"></p>
<pre><code class="javascript">// 这里简单的模拟一下 react 16版本调度，调和（含diff算法）的大纲过程
// 根据 虚拟DOM 信息 构建 fiber树【workLoop】，每一个fiber节点都是一个函数/任务【performUnitOfWork】
let nextUnitOfWork = null;
let workInProgressRoot = null;
function scheduleRoot(rootFible) &#123;
    nextUnitOfWork = rootFible;
    workInProgressRoot = rootFible;
&#125;
function workLoop(deadLine) &#123;
  let shouldYield = false;
  while (nextUnitOfWork &amp;&amp; !shouldYield) &#123;
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    shouldYield = deadLine.timeRemaining() &lt; 1;
  &#125;
  if (!nextUnitOfWork) &#123;
    console.log(&quot;结束render&quot;);
  &#125; else &#123;
    requestIdleCallback(workLoop,&#123;timeout: 300&#125;);
  &#125;
&#125;

function performUnitOfWork(curNode) &#123;
  // 源码里的beginWork，第一件事就是根据tag属性判断，然后执行不同的 updateComponent 方法
  // 在 updateComponent方法中调用了 reconcileChildren 方法，然后返回curNode.child
  // 相当于 performUnitOfWork整个函数可以简化成 
  //  &#123;const child = beginWork(curNode); if(!child) completeUnitOfWork(curNode);&#125;
  beginWork(curNode);
  // 遍历找到最下层的子节点
  if (curNode.child) &#123;
    return curNode.child;
  &#125;
  while (curNode) &#123;
    // 源码里是将return sibling和重设curNode的逻辑放到了 completeUnitOfWork中
    completeUnitOfWork(curNode);
    if (curNode.sibling) return curNode.sibling;
    curNode = curNode.return;
  &#125;
&#125;

function beginWork(curNode) &#123;
  console.log(`开始: $&#123;curNode.key&#125;`);
&#125;

function completeUnitOfWork(curNode) &#123;
  console.log(`结束: $&#123;curNode.key&#125;`);
&#125;
scheduleRoot(root);
requestIdleCallback(workLoop,&#123;timeout: 300&#125;);

/**
开始: root
开始: firstChild
开始: firstSunNode
结束: firstSunNode
开始: secondSunNode
结束: secondSunNode
结束: firstChild
开始: secondChild
结束: secondChild
结束: root
结束render
 */
</code></pre>
<ol>
<li>其次引入了<code>window.requestIdleCallback</code>，对<code>workLoop()</code>函数的调度进行优化。每当performUnitOfWork构建完一个fiber 节点后，都会将线程控制权归还浏览器，如果有更高优先级任务需要执行，则放弃构建fiber树，如果没有则继续在下一次从浏览器拿到控制权时继续执行节点的构建。</li>
</ol>
<p>  —– 以上是react fiber的大致思路，源码层面其实就是干了一件递归改循环的事情 —–</p>
<p>为了更加形象深入的了解fiber以及为react 16版本diff铺路，以下粘贴一段网上关于 react fiber过程的介绍。</p>
<p> <img src="../images/diff/190406_24idh37ad28ig61f94ea6ckb108g4_1302x472.png" alt="img"> </p>
<ol>
<li>第一部分从 <code>ReactDOM.render()</code> 方法开始，把接收的React Element转换为Fiber节点，并为其设置优先级，记录update等。这部分主要是一些数据方面的准备工作。</li>
<li>第二部分主要是三个函数：<code>scheduleWork</code>、<code>requestWork</code>、<code>performWork</code>，即安排工作、申请工作、正式工作三部曲。React 16 新增的异步调用的功能则在这部分实现。</li>
<li>第三部分是一个大循环，遍历所有的Fiber节点，通过Diff算法计算所有更新工作，产出 EffectList 给到commit阶段使用。这部分的核心是 beginWork 函数。</li>
</ol>
<p>从<code>beginWork</code>来看，在<code>beginWork</code>阶段，<code>updateHostComponent</code>的时候会执行<code>reconcileChildFibers</code>或者<code>mountChildFibers(</code>初始化的时候)。主要分为两部分，一部分是对<code>Context</code>的处理，一部分是根据<code>fiber</code>对象的<code>tag</code>类型，调用对应的update方法（<strong>vdom diff的步骤就是在这里</strong>）：</p>
<ol>
<li>先更新classComponent的Instance，期间调用生命周期函数</li>
<li>根据shouldUpdate来判断是否需要更新</li>
<li>需要更新的话调用render()获得最新ReactElement</li>
<li>如果是新建节点直接mount，如果是更新类型则调用fiber协调算法</li>
<li><code>reconcileChildFibers</code>函数中主要是根据newChild类型，调用不同的Diff算法：<code>reconcileSingleElement、reconcileSinglePortal、reconcileSingleTextNode、reconcileChildrenArray</code>，在子节点上添加 <code>effectTag</code>记录变更类型如<code>placement</code></li>
<li><code>reconcileSingleElement</code>的diff方式可参考：<a target="_blank" rel="noopener" href="https://react.jokcy.me/book/flow/reconcile-children/single.html">https://react.jokcy.me/book/flow/reconcile-children/single.html</a> 。array子元素群的diff方式：<a target="_blank" rel="noopener" href="https://react.jokcy.me/book/flow/reconcile-children/array.html">https://react.jokcy.me/book/flow/reconcile-children/array.html</a></li>
<li>commit阶段做的事情是拿到<code>reconciliation</code>阶段产出的<code>EffectList</code>，即所有更新工作，提交这些更新工作并调用渲染模块（react-dom）渲染UI。</li>
</ol>
<p>最后通过事件触发进入到commitAllHostEffects里进行dom操作步骤。</p>
<h2 id="Diff"><a href="#Diff" class="headerlink" title="Diff"></a><i class="fa fa-tags"></i>Diff</h2><h3 id="react-15-Diff"><a href="#react-15-Diff" class="headerlink" title="react 15 Diff"></a>react 15 Diff</h3><!--diff算法在 react 15版本和 react 16版本中有不同的实现。这里先整理15版本的。-->

<h4 id="传统的Diff以及react-15的Diff"><a href="#传统的Diff以及react-15的Diff" class="headerlink" title="传统的Diff以及react 15的Diff"></a>传统的Diff以及react 15的Diff</h4><p>关于Diff算法，react官网有这样一段介绍：</p>
<p>传统的Diff算法通过循环递归对节点进行依次对比，效率低下，其算法复杂度达到 <code>O(n^3)</code>,其中n表示节点的个数。这就意味着，假如页面有1000个节点，那么每次就要执行上十亿次的对比。而如今的CPU每秒钟能够执行大约30亿条指令。</p>
<p>因此react官方基于传统Diff算法的基础上，制定了三条规则：</p>
<ol>
<li>WEB UI 中的DOM节点跨层级的移动操作特别少，可以忽略不计</li>
<li>拥有相同类的两个组件会生成相似的树形结构，不同类的两个组件，将会生成不同的树形结构</li>
<li>对于同一层级的一组子节点，可以通过key区分</li>
</ol>
<p>对于上述三条规则，简话即是： </p>
<ul>
<li><p> 不考虑跨层级移动，如果有那就卸载之前的，然后创建新的</p>
</li>
<li><p>基本不会考虑以下这种情况，如果有，那就按照卸载，再创建思路去考虑</p>
<pre><code class="jsx">function originTree() &#123;
    return (
        &lt;div&gt;
            &lt;span&gt;1&lt;/span&gt;
            &lt;span&gt;2&lt;/span&gt;
            &lt;span&gt;3&lt;/span&gt;
        &lt;/div&gt;
    );
&#125;

function newTree() &#123;
    return (
        &lt;p&gt;
            &lt;span&gt;1&lt;/span&gt;
            &lt;span&gt;2&lt;/span&gt;
            &lt;span&gt;3&lt;/span&gt;
        &lt;/p&gt;
    );
&#125;
</code></pre>
</li>
<li><p>为每个节点增加 key属性， 同一层级key相同，表示只需要考虑 同级移动</p>
</li>
</ul>
<p>—– 基于这三条规则，可以想象一下React 中对diff算法的 实现思路 —–</p>
<ol>
<li><p>比类型，类型不同，就创建新的替换</p>
</li>
<li><p>比属性，同一类型下，可以比较新旧的 props，需要置空的置空，需要增加的增加，需要修改值的修改</p>
</li>
<li><p>递归 children 重复上方操作</p>
<p><u>如果只是上面几步仍然是不够的，在React中还有一个点需要了解</u></p>
</li>
</ol>
<h4 id="React-patch"><a href="#React-patch" class="headerlink" title="React patch"></a>React patch</h4><p>在上述规则的基础上，通过diff算法，可以直接知道哪些节点是需要删除，哪些节点又是需要创建，哪些节点需要移动的。但是，在这种场景下，是不可能每比对一次，就调用DOM API修改一次DOM树的，这样的操作也仅仅是比原生的性能稍好一点。</p>
<p>因此，React 15通过打补丁的方式，基于Diff算法求出一个补丁对象——<code>patch</code>,然后再重新遍历旧的树，一次性批量更新。</p>
<h4 id="React-15-Diff-简单模拟"><a href="#React-15-Diff-简单模拟" class="headerlink" title="React 15 Diff 简单模拟"></a>React 15 Diff 简单模拟</h4><img src="../images/diff/1616510730475.png" alt="1616510730475" style="zoom:50%;" />

<img src="../images/diff/1616510680063.png" alt="1616510680063" style="zoom:50%;" />

<pre><code class="javascript">// diff.js
class Element &#123;
  constructor(type, props, children) &#123;
    this.type = type;
    this.props = props;
    this.children = children;
    this.key = props.key;
  &#125;
&#125;

function createElement(type, props, children) &#123;
  return new Element(type, props, children);
&#125;;

// 简单模拟react createElement，二者如上图展示
const lastVirtualDom = createElement(&quot;div&quot;, &#123; className: &quot;container&quot;, key: 0 &#125;, [
  createElement(&quot;li&quot;, &#123; className: &quot;item&quot;, key: 1 &#125;, [&quot;a&quot;]),
  createElement(&quot;li&quot;, &#123; className: &quot;item&quot;, key: 3 &#125;, [&quot;b&quot;]),
  // createElement(&quot;li&quot;, &#123; className: &quot;item&quot;, key: 5 &#125;, [&quot;c&quot;])
]);
const nextVirtualDom = createElement(&quot;div&quot;, &#123; className: &quot;container1&quot;, key: 0 &#125;, [
  createElement(&quot;li&quot;, &#123; className: &quot;item&quot;, key: 1 &#125;, [&quot;1&quot;]),
  createElement(&quot;li&quot;, &#123; className: &quot;item&quot;, key: 3 &#125;, [&quot;b&quot;]),
  createElement(&quot;li&quot;, &#123; className: &quot;item&quot;, key: 5 &#125;, [&quot;2&quot;])
]);

const ATTRS = &quot;ATTRS&quot;;
const TEXT = &quot;TEXT&quot;;
const REMOVE = &quot;REMOVE&quot;;
const REPLACE = &quot;REPLACE&quot;;
const ADD = &quot;ADD&quot;;
const MOVE = &quot;MOVE&quot;;

function diff(oldVDom, newVDom) &#123;
  const patches = &#123;&#125;;
  let index = 0; // index表示层级
  walk(oldVDom, newVDom, index, patches);
  return patches;
&#125;;

function isString(string) &#123;
  return typeof string === &#39;string&#39;;
&#125;;

function isArray(array) &#123;
  return Array.isArray(array);
&#125;;

function diffAttribute(oldVDomProps, newVDomProps) &#123;
  const currentPatches = &#123;&#125;;
  for (let attrName in oldVDomProps) &#123; // 在旧的props中，比对新旧，存留新值
    if (oldVDomProps[attrName] !== newVDomProps[attrName]) &#123;
      currentPatches[attrName] = newVDomProps[attrName];
    &#125;
  &#125;
  for (let attrName in newVDomProps) &#123;
    //新的属性值在旧节点不存在
    if (!oldVDomProps.hasOwnProperty(attrName)) &#123;
      currentPatches[key] = newVDomProps[attrName];
    &#125;
  &#125;
  return currentPatches;
&#125;;

let tempKeyMap = &#123;&#125;;
function diffChildren(oldChildren, newChildren, index, patches) &#123;
  if (isArray(oldChildren) &amp;&amp; isArray(newChildren)) &#123;
    const oldChildrenLen = oldChildren.length;
    const newChildrenLen = newChildren.length;
    const maxLen = Math.max(oldChildrenLen, newChildrenLen);
    for (var i = 0; i &lt; oldChildren.length; i++) &#123;
      if (oldChildren[i].key) &#123;
        tempKeyMap[oldChildren[i].key] = &#123; node: oldChildren[i], index: (index+1 + i) &#125;
      &#125;
    &#125;
    for (var i = 0; i &lt; maxLen; i++) &#123;
      // 由于是深度优先遍历，且index是全局的，所以这边在遍历的同时，index是全局改变，且会累加上子元素的下标
      // 这样结束子元素遍历，去往父级的兄弟元素开始的时候，
      // 下标正好符合 根 0 =&gt; 父1 =&gt; 子2 =&gt; 叔3 =&gt; 叔.子 4这样排列
      walk(oldChildren[i], newChildren[i], ++index + i, patches);
    &#125;
    tempKeyMap = &#123;&#125;;
  &#125;
&#125;

function walk(oldVDom, newVDom, index, patches) &#123;
  const differences = [];
  if (!newVDom) &#123;
    differences.push(&#123; type: REMOVE, index &#125;);
  &#125; else if (newVDom.key &amp;&amp; tempKeyMap[newVDom.key]) &#123;
    console.log(index, tempKeyMap[newVDom.key].index,&#39;=&#39;)
    if (index &gt; tempKeyMap[newVDom.key].index) &#123;
      differences.push(&#123; type: MOVE, node: newVDom, sourceIndex: index, targetIndex: tempKeyMap[newVDom.key].index&#125;)
    &#125;
  &#125; else if (!oldVDom &amp;&amp; newVDom) &#123;
    differences.push(&#123; type: ADD, node: newVDom &#125;);
  &#125; else if (isString(oldVDom) &amp;&amp; isString(newVDom)) &#123;
    if (oldVDom !== newVDom) &#123;
      differences.push(&#123; type: TEXT, text: newVDom &#125;)
    &#125;
  &#125; else if (oldVDom.type === newVDom.type) &#123;
    const attrs = diffAttribute(oldVDom.props, newVDom.props);
    if (Object.keys(attrs).length) &#123;
      differences.push(&#123; type: ATTRS, attrs &#125;);
    &#125;
    // 比对完当前节点属性后，还需要遍历children
    diffChildren(oldVDom.children, newVDom.children, index, patches);
  &#125; else &#123;
    differences.push(&#123; type: REPLACE, node: newVDom &#125;);
  &#125;
  if (differences.length &gt; 0) &#123;
    patches[index] = differences;
  &#125;
&#125;;

console.log(diff(lastVirtualDom, nextVirtualDom));
/**
 * &#123; 
     &#39;0&#39;: [ &#123; type: &#39;ATTRS&#39;, attrs: [Object] &#125; ],
      &#39;2&#39;: [ &#123; type: &#39;TEXT&#39;, text: &#39;1&#39; &#125; ],
      &#39;5&#39;: [ &#123; type: &#39;ADD&#39;, node: [Element] &#125; ] 
      &#125;
 */
// patches.js
let allPatches;
let index = 0;
function patch(node, patches) &#123;
  allPatches = patches;
  // console.log(node);
  walk(node);
&#125;
function walk(node) &#123;
  let currentPatch = allPatches[index++];
  let childNodes = node.childNodes;
  childNodes.forEach((child) =&gt; walk(child));
  if (currentPatch) &#123;
    doPatch(node, currentPatch);
  &#125;
&#125;
function doPatch(node, patches) &#123;
  patches.forEach((patch) =&gt; &#123;
    switch (patch.type) &#123;
      case &quot;ATTRS&quot;:
        for (let key in patch.attrs) &#123;
          let value = patch.attrs[key];
          if (value) &#123;
            setAttr(node, key, value);
          &#125; else &#123;
            node.removeAttribute(key);
          &#125;
        &#125;
        break;
      case &quot;TEXT&quot;:
        node.textContent = patch.text;
        break;
      case &quot;REMOVE&quot;:
        node.parentNode.removeChild(node);
        break;
      case &quot;REPLACE&quot;:
        let newNode =
          patch.newNode instanceof Element
            ? render(patch.newNode)
            : document.createTextNode(patch.newNode);
        node.parentNode.repalceChild(newNode, node);
        break;
      case &quot;ADD&quot;:
        let newNode =
          patch.newNode instanceof Element
            ? render(patch.newNode)
            : document.createTextNode(patch.newNode);
         node.parentNode.appendChild(newNode);
         break;
      default:
        break;
    &#125;
  &#125;);
&#125;
</code></pre>
<p>补充 <code>TODO</code>: </p>
<ol>
<li>同级移动： 其思路是遍历同级的时候，先生成一个map存放key，并对应VDOM，diff的时候，比对一下key是否有相同的，如果有，且位置发生改变，记录一下 sourceIndex,targetIndex到patches中。</li>
<li>简化版demo,如有bug实属正常，后续待深入了解完善 ，凑合着看 </li>
</ol>
<h3 id="React-16-Diff"><a href="#React-16-Diff" class="headerlink" title="React 16 Diff"></a>React 16 Diff</h3><h4 id="Fiber节点数据结构"><a href="#Fiber节点数据结构" class="headerlink" title="Fiber节点数据结构"></a>Fiber节点数据结构</h4><pre><code class="javascript">export type Fiber = &#123;
  ...,                     
  tag: TypeOfWork, // number类型，区分原生标签，function，class,text等等
  key: null | string,
  type: any,
  // 这个可以理解为是节点的实例，它和type在很多场景是一致的，但是也有特例
  //  type: &quot;div&quot;, stateNode: &quot;div&quot;
  //  type: &quot;Function&quot;, stateNode: null, 
  //  当fiber node的type是函数式组件或class组件的时候，是没有stateNode的，
  //  但是 function() 返回的和class.render返回的 jsx，他们有stateNode
  stateNode: any, 
  return: Fiber | null, // 父节点
  child: Fiber | null,  // 第一个子节点
  sibling: Fiber | null, // 兄弟节点
  index: number,
  ref: null | (((handle: mixed) =&gt; void) &amp; &#123;_stringRef: ?string&#125;) | RefObject,
  // 标记， diff过程中添加的值
  effectTag: TypeOfSideEffect,
  // 当前fiber节点的一个克隆体,（这个属性牵扯到**双缓冲机制，后面需要了解一下），用在current树和workInProgress树中，新树节点对应旧树节点。
  alternate: Fiber | null, 
&#125;;
</code></pre>
<h4 id="Diff源码记录"><a href="#Diff源码记录" class="headerlink" title="Diff源码记录"></a>Diff源码记录</h4><p>之前有提及，在ReactFiberBeginWork.js/beginWork中会调用一个 reconcileChildren方法，该方法比较简单，仅判断了是否是初次渲染， 如果是初次则调用mountChildFibers，否则就执行reconcileChildFibers。</p>
<p>而reconcileChildFibers中则又根据当前fiber节点的tag，来决定调用不同的方法更新子节点。所以从reconcileChildFibers入手。</p>
<img src="../images/diff/1616928441387.png" alt="1616928441387" style="zoom:40%;" />

<h5 id="reconcileSingleElement"><a href="#reconcileSingleElement" class="headerlink" title="reconcileSingleElement"></a>reconcileSingleElement</h5><pre><code class="javascript">//returnFiber就是 workInProgress
// currentFirstChild就是workInProgress.alternate的child（如果存在的话） | 
// element是 newChild,也是 当前workInProgress(fiber节点)的children
// expirationTime过期时间
function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime): Fiber &#123;
    const key = element.key;
    let child = currentFirstChild;
    //初始渲染这个currentFirstChild直接传的null，所以更新时候才会diff
    while (child !== null) &#123;
      //查看节点是否可以复用
      if (child.key === key) &#123;
        switch (child.tag) &#123;
            ...
          default: &#123;
            //节点类型也相同
            if (child.elementType === element.type) &#123;
              // 相同的老的节点的兄弟节点清空  为了本次可以复用
              deleteRemainingChildren(returnFiber, child.sibling);
              // useFiber可以看作只是用来clone一个fiber节点，但它的sibling被置空了， effectTag被设置成了和初始化创建一样的值:NoWork(无更新);
              const existing = useFiber(child, element.props);
              ...
              return existing;
            &#125;
            break;
          &#125;
        &#125;
        // key相同但是节点类型不同，无法复用，其兄弟节点也需要删除
        //**问题：【这个场景暂时没明白为什么，个人认为变的是自己，又不是父级，为何要在自己的类型不同时删除sibling】
        /*
        * while (childToDelete !== null) &#123;
        *  deleteChild(returnFiber, childToDelete);
        *  childToDelete = childToDelete.sibling;
          * &#125;
        */
        deleteRemainingChildren(returnFiber, child);
        break;
      &#125; else &#123;
        // key不相同 无法服用，但是其兄弟可能还会复用上次的
        deleteChild(returnFiber, child);
      &#125;
      child = child.sibling;
    &#125;
    //上面如果执行完没有可复用的 则进入这里进行创建
    if (element.type === REACT_FRAGMENT_TYPE) &#123;
      ...
    &#125; else &#123;
      const created = createFiberFromElement(...);
      ...
      return created;
    &#125;
  &#125;
</code></pre>
<h5 id="reconcileSingleTextNode"><a href="#reconcileSingleTextNode" class="headerlink" title="reconcileSingleTextNode"></a>reconcileSingleTextNode</h5><p>reconcileSingleTextNode方法比reconcileSingleElement代码量少，而且基本类似，只是少了<code>while(!child)</code>遍历兄弟节点这一块逻辑</p>
<pre><code class="javascript">  ....
  if (currentFirstChild !== null &amp;&amp; currentFirstChild.tag === HostText) &#123;
    //删除兄弟
    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
    //复用
    const existing = useFiber(currentFirstChild, textContent);
    existing.return = returnFiber;
    return existing;
  &#125;
  .....
</code></pre>
<h5 id="reconcileChildrenArray"><a href="#reconcileChildrenArray" class="headerlink" title="reconcileChildrenArray"></a>reconcileChildrenArray</h5><pre><code class="javascript">    function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) &#123;
      ...

      var resultingFirstChild = null;
      var previousNewFiber = null;
      var oldFiber = currentFirstChild;
      var lastPlacedIndex = 0;
      var newIdx = 0;
      var nextOldFiber = null;
      // 遍历子节点数组，用旧节点的index去和新节点数组的index去比对 
      // 循环结束场景： 
      //   1. 新旧长度一致，新旧都遍历完成
      //   2. 新的比旧的短，新的完成遍历
      //   3. 新的比旧的长，旧的遍历完成 oldFiber === null,跳出循环
      for (; oldFiber !== null &amp;&amp; newIdx &lt; newChildren.length; newIdx++) &#123;
        // 取相同位置的新旧节点，
        if (oldFiber.index &gt; newIdx) &#123;
          // 当oldFiber.index大于index时，表示旧链长度大于了新链长度了
          // ** 问题：上行理解感觉有点悖论，如果旧链长度大于新链，那么循环都结束了，为什么要加这个判断
          nextOldFiber = oldFiber;
          oldFiber = null;
        &#125; else &#123;
          // 这里相当于取旧节点的兄弟节点作为下一次循环的，在最下面 `oldFiber = nextOldFiber`
          nextOldFiber = oldFiber.sibling;
        &#125;
         //这里面根据key 判断是否可以复用节点
        var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);

        if (newFiber === null) &#123;
          if (oldFiber === null) &#123;
            oldFiber = nextOldFiber;
          &#125;

          break;
        &#125;
        ....
        oldFiber = nextOldFiber;
        
    &#125;
    // -------------------------   
     
    // 这里表示新链遍历结束后，假设旧链还存在值，则需要删除旧链多余的节点
    if (newIdx === newChildren.length) &#123;
        // We&#39;ve reached the end of the new children. We can delete the rest.
        deleteRemainingChildren(returnFiber, oldFiber);
        return resultingFirstChild;
    &#125;
        // 旧节点遍历完 新节点还有值 [a,b] =&gt; [a,b,c]
    if (oldFiber === null) &#123;
      //遍历 插入标记
      for (; newIdx &lt; newChildren.length; newIdx++) &#123;
        const newFiber = createChild(...); //创建新的fiber节点
        // 插入标记 
        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
        ...
      &#125;
      return resultingFirstChild;
    &#125;
    // 这里返回了一个map结构， 其目的是遍历了旧fiber及其兄弟节点，按照有key则取key，无key则index
    // 作为map的key，存储 【 existingChildren.set(existingChild.key, existingChild)】
    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
    // 下面还有一次遍历
</code></pre>
<p>  <code>updateFromMap</code> 和 <code>updateSlot</code> 的区别，内容逻辑是一致的，但是这里不再通过单纯的 <code>key</code> 判定是否可复用，而是通过新建的 <code>map</code> 对象中取旧节点，如果能取到意味着可以复用旧节点，反之创建新节点： </p>
<pre><code class="javascript">for (; newIdx &lt; newChildren.length; newIdx++) &#123;
  const newFiber = updateFromMap(...); // 这里正常情况下会返回值  复用或新创建 和updateSlot不同
  if (newFiber !== null) &#123;
    if (shouldTrackSideEffects) &#123;
      if (newFiber.alternate !== null) &#123;
        // 新的节点是复用老节点  从Map对象中删除旧节点值
        existingChildren.delete(
          newFiber.key === null ? newIdx : newFiber.key,
        );
      &#125;
    &#125;
    // 更新index 判定哪些节点需要被标记 插入effectTag
    // placeChild 函数 通过alternate属性取了旧树节点，，如果没有，则newFiber是创建
    // 如果有则判断二者的index，如果旧index小于 lastPlacedIndex，则打上移动的effectTag
    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
    if (previousNewFiber === null) &#123;
      //返回时候只需要返回自己   因为兄弟节点都挂载到自己身上了
      resultingFirstChild = newFiber;
    &#125; else &#123;
      //不停的给自己追加兄弟 a---&gt;b---&gt;c---&gt;d
      previousNewFiber.sibling = newFiber;
    &#125;
    previousNewFiber = newFiber;
  &#125;
&#125;

if (shouldTrackSideEffects) &#123;
  //旧节点中还存在，没法被复用  这里需要遍历删除
  existingChildren.forEach(child =&gt; deleteChild(returnFiber, child));
&#125;
// 只需要返回第一个节点即可   后面兄弟通过 slibling连接
return resultingFirstChild;
&#125;
</code></pre>
<p>关于 placeChild 函数，从网上摘了个例子描述一下其具体功能：</p>
<pre><code class="javascript"> function placeChild(newFiber, lastPlacedIndex, newIndex) &#123;
      newFiber.index = newIndex;

      if (!shouldTrackSideEffects) &#123;
        // Noop.
        return lastPlacedIndex;
      &#125;

      var current = newFiber.alternate;

      if (current !== null) &#123;
        var oldIndex = current.index;

        if (oldIndex &lt; lastPlacedIndex) &#123;
          // This is a move.
          newFiber.effectTag = Placement;
          return lastPlacedIndex;
        &#125; else &#123;
          // This item can stay in place.
          return oldIndex;
        &#125;
      &#125; else &#123;
        // This is an insertion.
        newFiber.effectTag = Placement;
        return lastPlacedIndex;
      &#125;
    &#125;
</code></pre>
<p> <strong>绿色线条代表复用节点且无操作，黄色代表移动操作，蓝色插入，红色删除</strong>： </p>
<p> <img src="../images/diff/20200809100634741.png" alt="img"> </p>
<pre><code class="reStructuredText">新节点 key1，Map 集合中存在 key1 则取出复用，key1 老节点的 oldIndex 为 1，不满足 oldIndex &lt; lastPlacedIndex，返回 oldIndex，并且赋值给 lastPlacedIndex 值更新为 1。

新节点 key2，Map 集合中存在 key2 则取出复用，key2 老节点的 oldIndex 为 2，不满足 oldIndex &lt; lastPlacedIndex，返回 oldIndex，并且赋值给 lastPlacedIndex 值更新为 2。

新节点 key0，Map 集合中存在 key0 则取出复用，key0 老节点的 oldIndex 为 0，满足 oldIndex &lt; lastPlacedIndex，则将 key0 标记为插入，返回 lastPlacedIndex。
</code></pre>
<p> <img src="../images/diff/20200809100908844.png" alt="img"> </p>
<pre><code class="reStructuredText">新节点 key1，Map 集合中存在 key1 则取出复用，key1 老节点的 oldIndex 为 1，不满足 oldIndex &lt; lastPlacedIndex，返回 oldIndex，并且赋值给 lastPlacedIndex 值更新为 1。

新节点 key5，Map 集合中不存在 key5 新建节点，不满足 current !== null，则将 key5 标记为插入，返回 lastPlacedIndex。

新节点 key3，Map 集合中存在 key3 则取出复用，key3 老节点的 oldIndex 为 3，不满足 oldIndex &lt; lastPlacedIndex，返回 oldIndex，并且赋值给 lastPlacedIndex 值更新为 3。

新节点 key0，Map 集合中存在 key0 则取出复用，key0 老节点的 oldIndex 为 0，满足 oldIndex &lt; lastPlacedIndex，则将 key0 标记为插入，返回 lastPlacedIndex。

剩余节点 key2 通过 existingChildren 遍历删除，被复用过的节点因为从 map 集合中已经移除了，所以这里的删除只是为未复用的。
</code></pre>
<h2 id="基于diff的开发建议"><a href="#基于diff的开发建议" class="headerlink" title="基于diff的开发建议"></a><strong>基于diff的开发建议</strong></h2><ul>
<li>基于tree diff：</li>
</ul>
<p>(1) 开发组件时，注意保持DOM结构的稳定；即，尽可能少地动态操作DOM结构，尤其是移动操作。</p>
<p>(2) 当节点数过大或者页面更新次数过多时，页面卡顿的现象会比较明显。这时可以通过 CSS 隐藏或显示节点，而不是真的移除或添加 DOM 节点。</p>
<ul>
<li>基于component diff：</li>
</ul>
<p>(1) 注意使用 shouldComponentUpdate() 来减少组件不必要的更新。</p>
<p>(2) 对于类似的结构应该尽量封装成组件，既减少代码量，又能减少component diff的性能消耗。</p>
<ul>
<li>基于element diff：</li>
</ul>
<p>(1) 对于列表结构，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。</p>
<h2 id="参考链接（附）："><a href="#参考链接（附）：" class="headerlink" title="参考链接（附）："></a>参考链接（附）：</h2><p><a target="_blank" rel="noopener" href="https://codesandbox.io/s/dom-diffgengxinshitu-e8j3n?file=/src/patch.js">https://codesandbox.io/s/dom-diffgengxinshitu-e8j3n?file=/src/patch.js</a></p>
<p><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/reconciliation.html#the-diffing-algorithm">https://zh-hans.reactjs.org/docs/reconciliation.html#the-diffing-algorithm</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av714591492/">https://www.bilibili.com/video/av714591492/</a><br>        <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cE411B7by?from=search&amp;seid=3682473561399472505">https://www.bilibili.com/video/BV1cE411B7by?from=search&amp;seid=3682473561399472505</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/y805939188/simple-react/blob/master/src/my-react/react-dom/react-dom.js">https://github.com/y805939188/simple-react/blob/master/src/my-react/react-dom/react-dom.js</a></p>
<p>** <a target="_blank" rel="noopener" href="http://www.ayqy.net/blog/dive-into-react-fiber/">http://www.ayqy.net/blog/dive-into-react-fiber/</a></p>
<p><del>记录一下（**标记的都是需要后面花时间再看的）</del></p>
<p><img src="../images/diff/1616657196256.png" alt="1616657196256"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/27/v8-array/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="书生">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="埋书小楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/27/v8-array/" class="post-title-link" itemprop="url">v8-array数组底层实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-27 20:25:30" itemprop="dateCreated datePublished" datetime="2021-06-27T20:25:30+08:00">2021-06-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-29 21:25:06" itemprop="dateModified" datetime="2021-06-29T21:25:06+08:00">2021-06-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>题目：数组: 100万个成员的数组取第一个和最后一个有性能差距吗?</p>
<p>答： 基本没有</p>
<pre><code class="reStructuredText">数组可以直接根据索引取的对应的元素，所以不管取哪个位置的元素的时间复杂度都是 O(1)

JavaScript 没有真正意义上的数组，所有的数组其实是对象，其“索引”看起来是数字，其实会被转换成字符串，作为属性名（对象的 key）来使用。所以无论是取第 1 个还是取第 10 万个元素，都是用 key 精确查找哈希表的过程，其消耗时间大致相同。
</code></pre>
<p>由上述问题，引发关于数组底层实现的概念介绍：</p>
<h2 id="1-js中的数组"><a href="#1-js中的数组" class="headerlink" title="1. js中的数组"></a>1. js中的数组</h2><ul>
<li><p>与普通的数组并非一致。它可以存放不同类型的数据，如<code>[1,&quot;1&quot;,function,obj]</code>,不局限于一种数据类型。</p>
</li>
<li><p>既像队列，有shift,unshift方法；也类似栈，有push,pop方法</p>
</li>
<li><p>能够迭代，有for，forEach等等</p>
</li>
<li><p>有length属性，能够访问数组的长度；同时也可以动态扩容，根据元素的数量，扩大或收缩内存容量</p>
</li>
</ul>
<h2 id="2-v8源码看数组"><a href="#2-v8源码看数组" class="headerlink" title="2. v8源码看数组"></a>2. v8源码看数组</h2><p> <img src="https://oscimg.oschina.net/oscnet/up-87b00d7f18659c5ddd73b09fb27a45828b1.png" alt="img"> </p>
<p>JSArray继承自JSObject,这也印证了一句<code>js中数组也是对象</code>。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/v8/v8/blob/master/src/objects/js-array.h">https://github.com/v8/v8/blob/master/src/objects/js-array.h</a></p>
<p>注意截图中的注释，其翻译成中文意即：</p>
<pre><code class="json">JSArray描述了JavaScript数组
这样的数组可以有两种模式:
-快速，后备存储是一个FixedArray和length &lt;= elements.length();
请注意:push和pop可以用来增加和缩小数组。
-慢，后备存储是一个HashTable与数字作为键
</code></pre>
<p>大概就是说，数组分为两种模式，一种是快速模式，它是基于fixedArray实现存储的；另一种是慢数组模式，它是基于HashTable实现存储。</p>
<p>既然有两种模式，那么就可以引申出第一个问题： 谁是默认情况下使用的模式？</p>
<p>答： <code>快数组模式</code>。</p>
<pre><code class="javascript">var a = [8,1,2];

// 打印 a的字节码：
- map = 0x939ebe04359 [FastProperties]
- prototype = 0x27e86e126289
- elements = 0xe70c791d4e9 &lt;FixedArray[3]&gt; [FAST_SMI_ELEMENTS (COW)]
- length = 3
- properties = 0x2b609d202241 &lt;FixedArray[0]&gt; &#123;
#length: 0x2019c3e58da9 &lt;AccessorInfo&gt; (const accessor descriptor)
&#125;
- elements= 0xe70c791d4e9 &lt;FixedArray[3]&gt; &#123;
0: 8
1: 1
2: 2
&#125;
</code></pre>
<p>引申：网上有一段资料， V8里面所有的数据类型的根父类都是Object，Object派生HeapObject，提供存储基本功能，往下的JSReceiver用于原型查找，再往下的JSObject就是JS里面的Object，Array/Function/Date等继承于JSObject。左边的FixedArray是实际存储数据的地方。 </p>
<p> <img src="../images/v8-array/1.png" alt="img"> </p>
<h3 id="2-2-快数组（FastElements）"><a href="#2-2-快数组（FastElements）" class="headerlink" title="2.2 快数组（FastElements）"></a>2.2 快数组（FastElements）</h3><p> 快数组是一种线性的存储方式，内部存储是连续的内存，新创建的空数组，默认的存储方式是快数组，快数组长度是可变的，可以根据元素的增加和删除来动态调整存储空间大小，内部是通过扩容和收缩机制实现。 </p>
<pre><code class="javascript">// v8/src/objects/js-array.h 
// Number of element slots to pre-allocate for an empty array.
  static const int kPreallocatedArrayElements = 4;
</code></pre>
<p>数组初始化时会默认产生4个插槽。</p>
<h4 id="2-2-1-扩容"><a href="#2-2-1-扩容" class="headerlink" title="2.2.1 扩容"></a>2.2.1 扩容</h4><p>当执行push等操作时，如果发现内存不够时：</p>
<pre><code class="javascript">// v8/src/objects/js-objects.h // 计算扩容后的容量
static const uint32_t kMinAddedElementsCapacity = 16;
// Computes the new capacity when expanding the elements of a JSObject.
static uint32_t NewElementsCapacity(uint32_t old_capacity) &#123;
    // (old_capacity + 50%) + kMinAddedElementsCapacity
    return old_capacity + (old_capacity &gt;&gt; 1) + kMinAddedElementsCapacity;
&#125;
// code-stub-assembler.cc
Node* CodeStubAssembler::CalculateNewElementsCapacity(Node* old_capacity,
                                                      ParameterMode mode) &#123;
  CSA_SLOW_ASSERT(this, MatchesParameterMode(old_capacity, mode));
  Node* half_old_capacity = WordOrSmiShr(old_capacity, 1, mode);
  Node* new_capacity = IntPtrOrSmiAdd(half_old_capacity, old_capacity, mode);
  Node* padding =
      IntPtrOrSmiConstant(JSObject::kMinAddedElementsCapacity, mode);
  return IntPtrOrSmiAdd(new_capacity, padding, mode);
&#125;
</code></pre>
<p>换算一下就是：</p>
<p><code>old_capacity + old_capacity / 2 + 16</code> ；即原内存大小的1.5倍 加上16。</p>
<p>所以，扩容可以分为以下几步：</p>
<ul>
<li>push 操作时，发现数组内存不足</li>
<li>申请 new_capacity = old_capacity /2 + old_capacity + 16 那么长度的内存空间</li>
<li>将数组拷贝到新内存中</li>
<li>把新元素放在当前 length 位置</li>
<li>数组的 length + 1</li>
<li>返回 length</li>
</ul>
<h4 id="2-2-2-收缩"><a href="#2-2-2-收缩" class="headerlink" title="2.2.2 收缩"></a>2.2.2 收缩</h4><pre><code class="javascript"> if (2 * length + JSObject::kMinAddedElementsCapacity &lt;= capacity) &#123;
     // 可以理解成 2 * length + 16 &lt;= capacity，也就是 当前元素数量的2倍 + 16 小于数组预定内存大小
     
     // If more than half the elements won&#39;t be used, trim the array.
     // Do not trim from short arrays to prevent frequent trimming on
     // repeated pop operations.
     // Leave some space to allow for subsequent push operations.
     
     // 判断： 根据length + 1 和old_length 决定是收缩空余的一半，还是全部收缩掉
     int elements_to_trim = length + 1 == old_length
         ? (capacity - length) / 2
     : capacity - length;
     isolate-&gt;heap()-&gt;RightTrimFixedArray(*backing_store, elements_to_trim);
     // Fill the non-trimmed elements with holes.
     BackingStore::cast(*backing_store)
         .FillWithHoles(length,
                        std::min(old_length, capacity - elements_to_trim));
 &#125; else &#123;
    // Otherwise, fill the unused tail with holes.
    // 反之，用 空洞对象 填充(holes对象指的是数组中分配了空间，但是没有存放元素的位置)
    BackingStore::cast(*backing_store)-&gt;FillWithHoles(length, old_length);
&#125;
</code></pre>
<p>执行pop操作后， 如果超过一半的元素没有被使用，则修剪数组。</p>
<h4 id="2-2-3-holes"><a href="#2-2-3-holes" class="headerlink" title="2.2.3 holes"></a>2.2.3 holes</h4><p> 对于<code>HOLES</code>，在<code>Fast Elements</code>模式中有一个扩展，称为<code>Fast Holey Elements</code>模式 。</p>
<p>意思是值，在连续内存中，部分索引存有数据，而另一部分索引不存在数据。用代码解释是：</p>
<pre><code class="javascript">var a = [2,3,4];
a[100] = 5;
</code></pre>
<p>访问a[5]时，得到的是undefined，而在控制台打印a时，也可以看到，输出的值中存在 <code>empty</code>这样的关键字。</p>
<h3 id="2-3-慢数组（SlowElements）"><a href="#2-3-慢数组（SlowElements）" class="headerlink" title="2.3 慢数组（SlowElements）"></a>2.3 慢数组（SlowElements）</h3><p> 慢数组是一种字典的内存形式。不用开辟大块连续的存储空间，节省了内存，但是由于需要维护这样一个<code>HashTable</code>，其效率会比快数组低，<code>V8</code>中是以<code>Dictionary</code>的结构实现的慢数组。</p>
<pre><code class="c++">// src/objects/dictionary.h
class EXPORT_TEMPLATE_DECLARE(V8_EXPORT_PRIVATE) Dictionary
    : public HashTable&lt;Derived, Shape&gt; &#123;
  using DerivedHashTable = HashTable&lt;Derived, Shape&gt;;

 public:
  using Key = typename Shape::Key;
  // Returns the value at entry.
  inline Object ValueAt(InternalIndex entry);
  inline Object ValueAt(const Isolate* isolate, InternalIndex entry);
  
  // ...
&#125;;
</code></pre>
<h3 id="2-4-快慢数组转化及区别"><a href="#2-4-快慢数组转化及区别" class="headerlink" title="2.4 快慢数组转化及区别"></a>2.4 快慢数组转化及区别</h3><p> 在V8中JSArray继承于JSObject。当设置属性的时候，会依次执行 <code>Object::SetProperty</code> 、 <code>Object::AddDataProperty</code> 、 <code>JSObject::AddDataElement</code> 、 <code>ShouldConvertToSlowElements</code> 。</p>
<h4 id="2-4-1-快-gt-慢"><a href="#2-4-1-快-gt-慢" class="headerlink" title="2.4.1 快 =&gt; 慢"></a>2.4.1 快 =&gt; 慢</h4><p> 快数组转换为慢数组主要有以下两种情况： </p>
<pre><code class="c++">// If the fast-case backing storage takes up much more memory than a dictionary
// backing storage would, the object should have slow elements.
// static
// 如果快速备份存储比字典占用更多的内存
// 备份存储，对象应该有慢元素。
// 静态

// src\objects\dictionary.h
// JSObjects prefer dictionary elements if the dictionary saves this much
// memory compared to a fast elements backing store.
static const uint32_t kPreferFastElementsSizeFactor = 3;
// ---------------
// src\objects\dictionary.h
class NumberDictionaryShape : public NumberDictionaryBaseShape &#123;
 public:
  static const int kPrefixSize = 1;
  static const int kEntrySize = 3;
&#125;;
// --- src\objects\js-objects-inl.h
static inline bool ShouldConvertToSlowElements(uint32_t used_elements,
                                               uint32_t new_capacity) &#123;
  uint32_t size_threshold = NumberDictionary::kPreferFastElementsSizeFactor *
                            NumberDictionary::ComputeCapacity(used_elements) *
                            NumberDictionary::kEntrySize;
  return size_threshold &lt;= new_capacity;
&#125;
</code></pre>
<p>将上述方法简化：</p>
<p>​    当 3* ComputeCapacity(used_elements) * 3  =&lt; 新的容量 时，返回true，表示要将快数组向慢数组转化。而关于 <code>ComputeCapacity</code></p>
<pre><code class="c++">static inline bool ShouldConvertToSlowElements(JSObject object,
                                               uint32_t capacity,
                                               uint32_t index,
                                               uint32_t* new_capacity) &#123;
  STATIC_ASSERT(JSObject::kMaxUncheckedOldFastElementsLength &lt;=
                JSObject::kMaxUncheckedFastElementsLength);
  if (index &lt; capacity) &#123;
    *new_capacity = capacity;
    return false;
  &#125;
    // 主要看这一行
  if (index - capacity &gt;= JSObject::kMaxGap) return true;
  *new_capacity = JSObject::NewElementsCapacity(index + 1);
  DCHECK_LT(index, *new_capacity);
  if (*new_capacity &lt;= JSObject::kMaxUncheckedOldFastElementsLength ||
      (*new_capacity &lt;= JSObject::kMaxUncheckedFastElementsLength &amp;&amp;
       ObjectInYoungGeneration(object))) &#123;
    return false;
  &#125;
  return ShouldConvertToSlowElements(object.GetFastElementsUsage(),
                                     *new_capacity);
&#125;
</code></pre>
<p><code>kMaxGap</code>,通过查找，定义的值为1024； 也就是说当 <code>加入的 index</code> - <code>当前容量</code> 大于等于 <code>1024</code> 时，（这时候存在的holes数量就会大于等于1024个）也会转变成慢数组。</p>
<pre><code class="javascript">let a = [1, 2]
a[1030] = 1;
</code></pre>
<p><img src="../images/v8-array/1621994110850.png" alt="1621994110850"></p>
<h4 id="2-4-2-慢-gt-快"><a href="#2-4-2-慢-gt-快" class="headerlink" title="2.4.2 慢 =&gt; 快"></a>2.4.2 慢 =&gt; 快</h4><p> 处于哈希表实现的数组，每次空间增长时， V8 的启发式算法都会检查其空间占用量 。</p>
<p>而慢转快，比较直白的做法就是 给数组填充真实的数据，保证 填充的index - 当前容量 &lt;= 1024时即会转成快数组。比如：</p>
<pre><code class="javascript">let a = [1,2];
a[1030] = 1;
//---
a[500] = &quot;填充&quot;;
</code></pre>
<pre><code class="javascript">// src\objects\js-objects.cc
</code></pre>
<img src="https://oscimg.oschina.net/oscnet/up-e4a4403ce1d020bcf03db57051e6cb77820.png" alt="img" style="zoom:50%;" />

 

<h4 id="2-4-3-区别对比"><a href="#2-4-3-区别对比" class="headerlink" title="2.4.3 区别对比"></a>2.4.3 区别对比</h4><ol>
<li><strong>存储方式方面：</strong>快数组内存中是连续的，慢数组在内存中是零散分配的。</li>
<li><strong>内存使用方面：</strong>由于快数组内存是连续的，可能需要开辟一大块供其使用，其中还可能有很多空洞，是比较费内存的。慢数组不会有空洞的情况，且都是零散的内存，比较节省内存空间。</li>
<li><strong>遍历效率方面：</strong>快数组由于是空间连续的，遍历速度很快，而慢数组每次都要寻找 key 的位置，遍历效率会差一些。</li>
</ol>
<h3 id="2-5-v8调试相关"><a href="#2-5-v8调试相关" class="headerlink" title="2.5 v8调试相关"></a>2.5 v8调试相关</h3><pre><code class="javascript">1.npm install -g jsvu
2.将.jsvu 所在的绝对路径添加到系统变量PATH中
3.执行 jsvu 命令，会话首先会提示你选择64/32位系统，其次会询问安装v8还是v8-debug。
建议安装v8-debug,它会比v8打印出来的数据要更为完整
</code></pre>
<hr>
<p>记录一下个人安装jsvu遇到的坑：</p>
<ol>
<li><p>node版本最好是 v14.16.0</p>
</li>
<li><p>执行完第一步后，去添加环境变量时，发现系统C盘，并没有.jsvu文件夹的存在，可以自己先建立一个同名文件，然后在当前路径打开终端，再执行<code>jsvu</code>。</p>
</li>
<li><p>执行<code>jsvu</code>之后，在终端敲 <code>v8</code> 命令时，如果发现终端提示v8不是一个命令；可以在终端重新执行一次 <code>jsvu</code>。这时候，会发现，在.jsvu文件夹下，新增了 <code>v8.cmd/v8-debug.cmd</code>文件及<code>xs.cmd</code>。</p>
</li>
<li><p>如果执行<code>jsvu</code>命令并且选择的是安装v8-debug后，在.jsvu文件夹下没有发现<code>v8-debug.cmd</code>文件，可以执行<code>jsvu --engines=v8-debug</code></p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/27/URL-and-URI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="书生">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="埋书小楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/27/URL-and-URI/" class="post-title-link" itemprop="url">URL-and-URI</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-27 20:23:15" itemprop="dateCreated datePublished" datetime="2021-06-27T20:23:15+08:00">2021-06-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-29 22:15:24" itemprop="dateModified" datetime="2021-06-29T22:15:24+08:00">2021-06-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="从语义上区分"><a href="#从语义上区分" class="headerlink" title="从语义上区分"></a>从语义上区分</h2><p>URI：全称<code>Uniform Resource Identifier</code>，是统一资源标识符</p>
<p>URL：全程<code>Uniform Resource Locator</code>，是统一资源定位符</p>
<p>前者类似于一个id或者说是身份证一类的东西， 后者则偏向于文件路径一类，但二者同时指向的都是一个东西。只不过这个东西（资源）有两个唯一性属性，一个是id，一个是位置。我们无论用哪个属性，都能具体确定到当前资源。因此可以说 URL是URI的一个子集。</p>
<p> <img src="../images/URL-and-URI/url.png" alt="img"> </p>
<p>从上图看，还有一个叫做URN的。那么URN又是啥？</p>
<p>URN:  <code>Uniform Resource Name </code>, 中文名：统一资源名称。百度说它是<code> 期望为资源提供持久的、位置无关的标识方式，并允许简单地将多个命名空间映射到单个URN命名空间</code>。 然而，很遗憾的是现在基本上见不到URN这种称呼了，可以说URN被URL取代，而也恰恰是这一点，可以 将 URI 无限类等于 URL。</p>
<p> “URI可以分为URL,URN或同时具备locators 和names特性的一个东西。URN作用就好像一个人的名字，URL就像一个人的地址。换句话说：URN确定了东西的身份，URL提供了找到它的方式。” ——-这是维基百科上的一段话，可以很形象的总结URL,URN,URI在语义上的区别。</p>
<h2 id="从结构上区分"><a href="#从结构上区分" class="headerlink" title="从结构上区分"></a><i class="fa fa-tags"></i>从结构上区分</h2><p>URL: </p>
<p>1、传送协议<br>        2、层级<code>URL</code>标记符号(为[//]，固定不变)<br>        3、访问资源需要的凭证信息(可省略)<br>        4、服务器(通常为域名，有时为IP地址)<br>        5、端口号(以数字方式表示，若为默认值可省略)<br>        6、路径(以”/“字符区别路径中的每一个目录名称)<br>        7、查询(<code>GET</code>模式的参数。以？字符为起点，每个参数以&amp;隔开，再以=分开参数名称与值，通常以UTF8的URL编码，避开字符冲突的问题)<br>        8、片段(以#字符为起点)</p>
<p>URI: </p>
<h2 id="从抽象和具体上区分"><a href="#从抽象和具体上区分" class="headerlink" title="从抽象和具体上区分"></a><i class="fa fa-tags"></i>从抽象和具体上区分</h2><p>毫无疑问，URI是一种抽象的东西，它仅标识了资源，负责识别；而URL是一种具体，它具体的告诉了你怎么找，去哪找这段资源，负责定位。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/27/react-router/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="书生">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="埋书小楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/27/react-router/" class="post-title-link" itemprop="url">react-router</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-27 19:25:24" itemprop="dateCreated datePublished" datetime="2021-06-27T19:25:24+08:00">2021-06-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-29 22:12:10" itemprop="dateModified" datetime="2021-06-29T22:12:10+08:00">2021-06-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <pre><code class="bash">$ npm install react-router-dom
</code></pre>
<h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h2><p>ReactRouter提供了以下三种基本组件，通过这三种组件组合使用，可以编写一个简单的路由跳转：</p>
<h3 id="1-1-BrowserRouter或HashRouter"><a href="#1-1-BrowserRouter或HashRouter" class="headerlink" title="1.1 BrowserRouter或HashRouter"></a>1.1 BrowserRouter或HashRouter</h3><ul>
<li><p>Router中包含了对路径改变的监听，并且会将相应的路径传递给子组件；</p>
</li>
<li><p>BrowserRouter使用history模式；</p>
</li>
<li><p>HashRouter使用hash模式；</p>
</li>
</ul>
<h3 id="1-2-Link"><a href="#1-2-Link" class="headerlink" title="1.2 Link"></a>1.2 Link</h3><ul>
<li><p>通常路径的跳转是使用Link组件，最终会被渲染成a元素；</p>
</li>
<li><p>activeStyle/activeClass属性，渲染路由被激活时的样式；</p>
</li>
<li><p>to属性：Link中最重要的属性，用于设置跳转到的路径；</p>
</li>
</ul>
<h3 id="1-3-Route"><a href="#1-3-Route" class="headerlink" title="1.3 Route"></a>1.3 Route</h3><ul>
<li><p>Route用于路径的匹配；</p>
</li>
<li><p>path属性：用于设置匹配到的路径；</p>
</li>
<li><p>component属性：设置匹配到路径后，渲染的组件；</p>
</li>
<li><p>exact：精准匹配，只有精准匹配到完全一致的路径，才会渲染对应的组件；</p>
</li>
</ul>
<h3 id="1-4-Redirect"><a href="#1-4-Redirect" class="headerlink" title="1.4 Redirect"></a>1.4 Redirect</h3><p>Redirect用于路由的重定向，当这个组件出现时，就会自动执行跳转到对应的to路径中;</p>
<h3 id="1-5-Switch"><a href="#1-5-Switch" class="headerlink" title="1.5 Switch"></a>1.5 Switch</h3><p>一般情况下，路由会出现以下情况：</p>
<pre><code class="html">&lt;Router&gt;
    &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125; /&gt;
    &lt;Route path=&quot;/about&quot; component=&#123;About&#125; /&gt;
    &lt;Route path=&quot;/profile&quot; component=&#123;Profile&#125; /&gt;
    &lt;Route path=&quot;/:userid&quot; component=&#123;User&#125;/&gt;
&lt;/Router&gt;
</code></pre>
<p>假设有一个路由  <code>localhost:8000/about</code>,这时候既会匹配到 <code>/profile</code>同时也会匹配到<code>/:userId</code>。这样一来，会同时渲染 Profile 和 User 两个组件。</p>
<p>而使用Switch包裹Route组件，则正是用于解决该类场景。</p>
<h3 id="1-6-示例"><a href="#1-6-示例" class="headerlink" title="1.6 示例"></a>1.6 示例</h3><pre><code class="javascript">import React from &quot;react&quot;;
import &#123;
  BrowserRouter as Router,
  Switch,
  Route,
  Link
&#125; from &quot;react-router-dom&quot;;

export default function App() &#123;
  return (
    &lt;Router&gt;
      &lt;div&gt;
        &lt;nav&gt;
          &lt;ul&gt;
            &lt;li&gt;&lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt;&lt;/li&gt;
            &lt;li&gt;&lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt;&lt;/li&gt;
            &lt;li&gt;&lt;Link to=&quot;/users&quot;&gt;Users&lt;/Link&gt;&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/nav&gt;
        &lt;Switch&gt;
          &lt;Route path=&quot;/about&quot; component=&#123;About&#125; /&gt;
          &lt;Route path=&quot;/users&quot; component=&#123;Users&#125; /&gt;
          &lt;Route path=&quot;/&quot; component=&#123;Home&#125; /&gt;
        &lt;/Switch&gt;
      &lt;/div&gt;
    &lt;/Router&gt;
  );
&#125;

function Home() &#123;
  return &lt;h2&gt;Home&lt;/h2&gt;;
&#125;

function About() &#123;
  return &lt;h2&gt;About&lt;/h2&gt;;
&#125;

function Users() &#123;
  return &lt;h2&gt;Users&lt;/h2&gt;;
&#125;
</code></pre>
<h2 id="2-源码探究"><a href="#2-源码探究" class="headerlink" title="2.源码探究"></a>2.源码探究</h2><h3 id="2-1-Router"><a href="#2-1-Router" class="headerlink" title="2.1 Router"></a>2.1 Router</h3><p>无论是<code>HashRouter</code>或<code>BrowserRouter</code>组件，源码都比较简单：</p>
<pre><code class="javascript">// node_modules\react-router-dom\modules\BrowserRouter.js
import &#123; createBrowserHistory as createHistory &#125; from &quot;history&quot;;
// import &#123; createHashHistory as createHistory &#125; from &quot;history&quot;;
class BrowserRouter extends React.Component &#123;
  history = createHistory(this.props);

  render() &#123;
    return &lt;Router history=&#123;this.history&#125; children=&#123;this.props.children&#125; /&gt;;
  &#125;
&#125;
</code></pre>
<p>都是使用的Router组件。只是不同的地方在于它们的history 属性值依赖 <code>history</code>提供的 <code>createHistory</code>方法不同而已，这里先暂不关注 <code>history</code>依赖包。</p>
<pre><code class="javascript">// node_modules\react-router\modules\Router.js
import React from &quot;react&quot;;
import HistoryContext from &quot;./HistoryContext.js&quot;;
import RouterContext from &quot;./RouterContext.js&quot;;

class Router extends React.Component &#123;
  static computeRootMatch(pathname) &#123;
    return &#123; path: &quot;/&quot;, url: &quot;/&quot;, params: &#123;&#125;, isExact: pathname === &quot;/&quot; &#125;;
  &#125;
  constructor(props) &#123;
    super(props);
    this.state = &#123;
      location: props.history.location
    &#125;;
  &#125;
  ....
  render() &#123;
    return (
      &lt;RouterContext.Provider
        value=&#123;&#123;
          history: this.props.history,
          location: this.state.location,
          match: Router.computeRootMatch(this.state.location.pathname),
          staticContext: this.props.staticContext
        &#125;&#125;
      &gt;
        &lt;HistoryContext.Provider
          children=&#123;this.props.children || null&#125;
          value=&#123;this.props.history&#125;
        /&gt;
      &lt;/RouterContext.Provider&gt;
    );
  &#125;
&#125;
</code></pre>
<p>由上可以得知以下几个结论:</p>
<ol>
<li>Router组件内部使用context</li>
<li>这里构造函数中将location作为自己的state，并且监听了location的变化</li>
</ol>
<h3 id="2-2-Route"><a href="#2-2-Route" class="headerlink" title="2.2 Route"></a>2.2 Route</h3><pre><code class="javascript">// node_modules\react-router\modules\Route.js
class Route extends React.Component &#123;
  render() &#123;
    return (
      &lt;RouterContext.Consumer&gt;
        &#123;context =&gt; &#123;
          ...
          const props = &#123; ...context, location, match &#125;;
          ...
          // 上面一大段的作用其实就是从context中获取Router中传递下来的value，然后经过一系列的处理
          // 组合成我们认知中包含有 &#123;history,mathch,location&#125;这样的props
          return (
            // 小疑问，为什么还要裹裹一次Provider,网上有人说是为了更好的处理嵌套路由
            &lt;RouterContext.Provider value=&#123;props&#125;&gt;
              // 渲染子组件
               // 这里props.match 牵扯到了matchPath.js 文件，里面引入了 path-to-regexp依赖
              // 借助这个依赖处理路由匹配，直观的说就是一段正则，匹配上就渲染，否则返回null
              &#123;props.match
                ? children
                  ? typeof children === &quot;function&quot;
                    ? __DEV__
                      ? evalChildrenDev(children, props, this.props.path)
                      : children(props)
                    : children
                  : component
                  ? React.createElement(component, props)
                  : render
                  ? render(props)
                  : null
                : typeof children === &quot;function&quot;
                ? __DEV__
                  ? evalChildrenDev(children, props, this.props.path)
                  : children(props)
                : null&#125;
            &lt;/RouterContext.Provider&gt;
          );
        &#125;&#125;
      &lt;/RouterContext.Consumer&gt;
    );
  &#125;
&#125;
</code></pre>
<p>从上诉代码中可以得知：</p>
<ol>
<li>在使用 <code>Route</code>组件的时候，渲染子组件优先去 找 children，如果没有再找component属性值，继而是render属性，如果这三者都没有则返回null</li>
<li>matchPath.js中定义了<code>matchPath</code>方法，它内部调用了<code>path-to-regexp</code>依赖，根据Router.state.location 中的pathname，也就是当前激活的路径，和Route组件上定义的path属性，正则匹配。【这里使用了依赖而不是采用自己编写或者使用 <code>===</code>/<code>includes</code>这样原生的方式，就在于要处理路由如<code>/:id</code>这种动态参数的情况，依赖会帮我们对<code>/:id</code>做正则转化。】同时在该方法中还处理好了params对象。</li>
</ol>
<h3 id="2-3-Swtich"><a href="#2-3-Swtich" class="headerlink" title="2.3 Swtich"></a>2.3 Swtich</h3><pre><code class="javascript">node_modules\react-router\modules\Switch.js
</code></pre>
<p>通过阅读源码，可以得知，其实现类似于<code>Route</code>组件。只不过，区别在于<code>Switch</code>组件内部是遍历它的子元素集合（this.props.children或者说是Route集合），然后在遍历过程中，通过正则去匹配路由对得上的子元素，返回渲染。唯一需要注意的是，它的子元素中，不仅仅是会有Route组件，还会有<code>Redirect</code>组件。</p>
<h2 id="3-hisotory"><a href="#3-hisotory" class="headerlink" title="3.hisotory"></a>3.hisotory</h2><h3 id="3-1-前言"><a href="#3-1-前言" class="headerlink" title="3.1 前言"></a>3.1 前言</h3><p>在了解history.js这个库之前，先对上面提到的 createHashHistory 和 createBrowserHistory贴上一段笔记：</p>
<ul>
<li><p>hashHistory带有#，#后面的内容不会发送服务器</p>
<ul>
<li> 通过改变地址后面的hash来改变浏览器的历史记录, 用到了window.loaction.hash对象（存，取） </li>
<li>类似于 a标签的锚点用法</li>
<li>window提供了一个 onhashchange 方法，监听 hashhistory的改变</li>
</ul>
</li>
<li><p>browserHistory和普通的url相同，使用/，但是需要服务端支持，如果服务没有正确配置，那么直接访问url就会发生404</p>
<ul>
<li>类似于请求</li>
</ul>
</li>
<li><p> 使用的是 HTML5 的 History API，浏览器提供相应的接口来修改浏览器的历史记录 </p>
</li>
</ul>
<h3 id="3-2-DOM-history-API"><a href="#3-2-DOM-history-API" class="headerlink" title="3.2 DOM history API"></a>3.2 DOM history API</h3><pre><code class="javascript">window.history.back(); // 在history中向后跳转,和用户点击浏览器回退按钮的效果相同
window.history.forward(); // 向前跳转（如同用户点击了前进按钮）
window.history.go(number); // 载入到会话历史中的某一特定页面
window.history.length // 查看长度属性的值来确定的历史堆栈中页面的数量
</code></pre>
<p>h5引入的新特性：</p>
<ol>
<li> history.pushState(state,title,url)</li>
</ol>
<p>   state：状态对象，自定义内容，可以通过history.state读取  </p>
<p>   title：标题，目前没什么作用</p>
<p>   url： 参数定义了新的历史URL记录 ，亦即改变后的url</p>
<ul>
<li>pushState改变url而不会刷新页面，  在某种意义上，调用 <code>pushState()</code> 与 设置 <code>window.location = &quot;#foo&quot;</code> ，但它不会触发<code>hashchange</code></li>
<li> 创建一个新的历史记录项 </li>
</ul>
<pre><code class="javascript">var stateObj = &#123; string: &quot;hello&quot; &#125;
window.history.pushState(stateObj, &quot;page 2&quot;, &quot;bar.html&quot;);
// 打印后会发现length较pushState之前，加一了
console.log(&quot;history.length after push:&quot;, window.history.length);
// &#123; string: &quot;hello &quot;&#125;
console.log(&quot;history.state after push:&quot;, window.history.state);
</code></pre>
<p>记录一点：如果是在谷歌内核浏览器下打开本地html文件运行上述代码，会报错如下：</p>
<pre><code class="javascript">Uncaught DOMException: Failed to execute &#39;pushState&#39; on &#39;History&#39;: A history state object with URL .....
</code></pre>
<p>这是因为出于安全性考虑，谷歌禁止这样的操作。但是放到服务器上，是可以的。即需要以http等协议开头；当然可以用IE浏览器测试。</p>
<p>另外，pushState并不会去校验 “bar.html”是否真实存在。</p>
<ol start="2">
<li><p>history.replaceState(state,title,url)</p>
<p>replaceState用于与pushState类似，只是它是替换，而不会创建一个新的历史记录。</p>
</li>
<li><p>window.onpopstate</p>
<p>  当浏览记录出现变化时，会触发此事件  </p>
</li>
</ol>
<pre><code>但是： 调用pushState和replaceState事件不会触发popstate事件，当点击后退或者前进按钮时才触发，或者调用go()方法触发;
</code></pre>
<p>   且： 假设你当前在bar.html，回撤后再go(1),再popstate中能够获取到你通过pushState时为bar.html设置的state,即它会保留state副本。</p>
<hr>
<p>   hash 和 browser history 在 API 方面的对比：</p>
<table>
<thead>
<tr>
<th></th>
<th>hash</th>
<th>browser</th>
</tr>
</thead>
<tbody><tr>
<td>修改路由</td>
<td>window.location.hash = “”</td>
<td>pushState,replaceState</td>
</tr>
<tr>
<td>监听</td>
<td>onhashchange</td>
<td>onpopstate</td>
</tr>
</tbody></table>
<h3 id="3-3-history库实现"><a href="#3-3-history库实现" class="headerlink" title="3.3 history库实现"></a>3.3 history库实现</h3><p>history 使用了发布订阅模式实现，内部对hashHistory,browserHistroy实现了push,pop,replace,go这一系列的函数，并维护了一个栈，用来记录路由历史。</p>
<pre><code class="javascript">// node_modules\history\cjs\history.js
exports.createBrowserHistory = createBrowserHistory;
exports.createHashHistory = createHashHistory;
exports.createMemoryHistory = createMemoryHistory;
exports.createLocation = createLocation;
exports.locationsAreEqual = locationsAreEqual;
exports.parsePath = parsePath;
exports.createPath = createPath;
</code></pre>
<p>history中主要暴露了以上几个方法，其中前三个实现思路基本一致。</p>
<p>这里以createHashHistory开始探究，记录代码调试的过程：</p>
<pre><code class="javascript">// createHashHistory
function createHashHistory(props) &#123;
    var globalHistory = window.history;
    ...   
    var transitionManager = createTransitionManager();
       ...
    var initialLocation = getDOMLocation();
      var allPaths = [createPath(initialLocation)];
    ...
    return (&#123;
        length: globalHistory.length, // window.history.length
        action: &#39;POP&#39;, // 路由的行为，（包含PUSH-进入、POP-弹出、REPLACE-替换）
        location: initialLocation, // location对象 来自getDOMLocation()
        createHref: createHref, // 当前地址（包含pathname）
        push: push,
        replace: replace,
        go: go, // go核心： globalHistory.go(n);
        goBack: goBack,  // go(-1);
        goForward: goForward, // go(1);
        block: block,
        listen: listen // 监听
    &#125;)
&#125;
</code></pre>
<p>简化了<code>createHashHistory</code>可以发现，整个函数做了以下事情：</p>
<ol>
<li>保存了一份window.history</li>
<li>使用了发布订阅模式，创建了一个<code>transitionManager</code>对象</li>
<li>创建了一个<code>location</code>对象</li>
<li>定义了一系列操作路由的方法</li>
<li>allPaths，代码在未往下继续研究前，可以推测其用来暂存历史path</li>
<li>返回了一个history对象</li>
</ol>
<p>因此 先从location开始。</p>
<h4 id="3-3-1-location"><a href="#3-3-1-location" class="headerlink" title="3.3.1 location"></a>3.3.1 location</h4><p>既然叫location，那么难免会联想到window.location，所以取了相同的pathname，这里做了一次打印：</p>
<pre><code class="javascript">// history.location
&#123;
    hash: &quot;&quot;
    pathname: &quot;/user/1/2&quot;
    search: &quot;&quot;
    state: undefined
&#125;
</code></pre>
<pre><code class="javascript">// window.location
&#123;
    ancestorOrigins: DOMStringList &#123;length: 0&#125;
    assign: ƒ assign()
    hash: &quot;#/user/1/2&quot;
    host: &quot;localhost:3000&quot;
    hostname: &quot;localhost&quot;
    href: &quot;http://localhost:3000/#/user/1/2&quot;
    origin: &quot;http://localhost:3000&quot;
    pathname: &quot;/&quot;
    port: &quot;3000&quot;
    protocol: &quot;http:&quot;
    reload: ƒ reload()
    replace: ƒ replace()
    search: &quot;&quot;
    toString: ƒ toString()
    valueOf: ƒ valueOf()
&#125;
</code></pre>
<p>可以看出 history.location 比较简洁，但近似window.location</p>
<p>而history.location = getDOMLocation();这个方法中，内部其实调用了另一个<code>createLocation</code>的方法，可以结论： <code>getDOMLocation内部处理入参，传递给createLocation，由它最终创建出history.location</code>。</p>
<pre><code class="javascript">// 简化 createLocation 后，可以知道，createLocation就是根据入参 格式化成一个含有state,pathname,hash,search的对象

function createLocation(path, state, key, currentLocation) &#123;
  var location;
  if (typeof path === &#39;string&#39;) &#123;
    // parsePath 方法用来 拆解 path ： &quot;#&quot;,&quot;?&quot;
    location = parsePath(path);
    location.state = state;
  &#125; else &#123;
   ...
  &#125;
  ...
  return location;
&#125;
function parsePath(path) &#123;
  var pathname = path || &#39;/&#39;;
  var search = &#39;&#39;;
  var hash = &#39;&#39;;
  var hashIndex = pathname.indexOf(&#39;#&#39;);

  if (hashIndex !== -1) &#123;
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  &#125;

  var searchIndex = pathname.indexOf(&#39;?&#39;);

  if (searchIndex !== -1) &#123;
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  &#125;

  return &#123;
    pathname: pathname,
    search: search === &#39;?&#39; ? &#39;&#39; : search,
    hash: hash === &#39;#&#39; ? &#39;&#39; : hash
  &#125;;
&#125;
</code></pre>
<h4 id="3-3-2-createHref"><a href="#3-3-2-createHref" class="headerlink" title="3.3.2 createHref"></a>3.3.2 createHref</h4><pre><code class="javascript"> // browsetHistory:
 function createHref(location) &#123;
    return basename + createPath(location);
 &#125;
 // hashHistory:
 function createHref(location) &#123;
    var baseTag = document.querySelector(&#39;base&#39;);
    var href = &#39;&#39;;

    if (baseTag &amp;&amp; baseTag.getAttribute(&#39;href&#39;)) &#123;
      href = stripHash(window.location.href);
    &#125;

    return href + &#39;#&#39; + encodePath(basename + createPath(location));
 &#125;
</code></pre>
<p>单独看createHashHistory里面的createHref可能不太好理解，这里将browsetHistory中的一块拿过来做对比，不难猜出 createHref 其实就是 path中 从“#”后面开始返回（“#/user/1/2”)</p>
<h4 id="3-3-3-allPaths"><a href="#3-3-3-allPaths" class="headerlink" title="3.3.3  allPaths"></a>3.3.3  allPaths</h4><p>通过打印，可以看到allPaths 是一个 字符串数组，其值为 path</p>
<pre><code class="javascript">// node_modules\history\esm\history.js : function push
nextPaths.push(path);
allPaths = nextPaths;
console.log(allPaths) // [&quot;/home&quot;,&quot;/usr/1/2&quot;]
</code></pre>
<h4 id="3-3-4-listen"><a href="#3-3-4-listen" class="headerlink" title="3.3.4 listen"></a>3.3.4 listen</h4><pre><code class="javascript">// home.js
useEffect(() =&gt; &#123;
    props.history.listen((e) =&gt; &#123;
      console.log(e,&#39;event&#39;)
    &#125;)
&#125;);
</code></pre>
<p>在业务代码 <code>home.js</code>文件中使用listen函数注册一个方法，可以看到，当路由改变时触发了该函数。也就是说，listen的作用等同于onHashChange。所以，可以合理推测：listen的作用，就是绑定一个自定义的回调函数，等待恰当的时机，使该回调被触发。</p>
<pre><code class="javascript">function appendListener(fn) &#123;
    var isActive = true;
    // 暂时没有用到，应该是出于未来优化考虑，提前内置了一个状态管理
    function listener() &#123;
        if (isActive) fn.apply(void 0, arguments);
    &#125;
    // 将传入的回调推入到全局 listeners数组中
    listeners.push(listener);
    return function () &#123;
        isActive = false;
        // 提供一个解绑方法
        listeners = listeners.filter(function (item) &#123;
            return item !== listener;
        &#125;);
    &#125;;
&#125;
</code></pre>
<p>在listen中还有一个<code>checkDOMListeners(1)</code>,内部根据传入的number，执行window.addEventListener/ window.removeEventListener。即对于dom提供的历史记录的监听。</p>
<p>有趣的是：</p>
<p>在createBrowserHistory中，checkDOMListeners 中window.addEventListener执行的是“popstate”，而createHashHistory中，执行的是”hashchange“。</p>
<h4 id="3-3-5-block"><a href="#3-3-5-block" class="headerlink" title="3.3.5 block"></a>3.3.5 block</h4><p>createHashHistory返回的history中，有一个属性为<code>block</code>，值为function。</p>
<p>其内部核心代码：</p>
<pre><code class="javascript"> transitionManager.setPrompt(prompt);
</code></pre>
<p>作用是提供一个方法给外界，当外界调用 props.history.block时，将入参也就是<code>prompt</code>存放到全局中。</p>
<p>当执行 push,go,replace等方法时，会有一句：</p>
<pre><code class="javascript">transitionManager.confirmTransitionTo(...)
</code></pre>
<p>该函数的作用：</p>
<ol>
<li>判断有无 prompt，没有则执行 confirmTransitionTo的callback</li>
<li>有prompt，则弹出浮窗，询问用户是否要执行 callback</li>
</ol>
<p>所以，该函数的本质类似于window.confirm。</p>
<h4 id="3-3-6-push-go-repelace"><a href="#3-3-6-push-go-repelace" class="headerlink" title="3.3.6 push/go/repelace"></a>3.3.6 push/go/repelace</h4><p>接续 3.3.5 中的block</p>
<p>push、replace内部实现基本一致。</p>
<ul>
<li><p>定义了action</p>
</li>
<li><p>根据入参path，调用createLocation方法，创建location</p>
</li>
<li><p>调用 transitionManager.confirmTransitionTo(location, action, getUserConfirmation,callback)</p>
<p>这里可以理解成： 调用一个function 返回了一个布尔值决定 传入的 callback是否执行。</p>
</li>
<li><p>block 返回true后 执行callback，callback中 执行 <code>setState</code>方法</p>
<p>confirmTransitionTo内部使用了block方法</p>
</li>
<li><p>setState触发 transitionManager.notifyListeners，发布消息，亦即触发<code>3.3.4 listen</code>里<code>appendListener</code>存放的函数，更新 <code>allPaths</code></p>
<p>callback中调用 setState方法</p>
</li>
</ul>
<p>而 go方法，在 createHashHistory中，只是借助了浏览器的API：</p>
<pre><code class="javascript">globalHistory.go(n); // window.hisotry.go
</code></pre>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>history:  <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903729611669511">https://juejin.cn/post/6844903729611669511</a></p>
<p>rc源码：<a target="_blank" rel="noopener" href="https://github.com/ReactTraining/react-router.git">https://github.com/ReactTraining/react-router.git</a></p>
<p>history源码： <a target="_blank" rel="noopener" href="https://github.com/ReactTraining/history.git">https://github.com/ReactTraining/history.git</a></p>
<p>DOM history API: <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API">https://developer.mozilla.org/zh-CN/docs/Web/API/History_API</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">书生</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="/js/canvas-nest.js"></script>


    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
